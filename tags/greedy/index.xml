<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>greedy on zayn_lie&#39;s blog</title>
        <link>/tags/greedy/</link>
        <description>Recent content in greedy on zayn_lie&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 05 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/greedy/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>从0开始的算法竞赛01-算法基础03：贪心</title>
        <link>/posts/algorithm/01-basis/2023-03-05-03-greedy/</link>
        <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-05-03-greedy/</guid>
        <description>&lt;h3 id=&#34;why-为什么要学贪心算法&#34;&gt;WHY: 为什么要学贪心算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我相信大家愿意跟着我建立算法和 c++ 体系的原因是体系的逻辑性及减少凭感觉解决问题，这也是本博客的目的。但是，凡事没有绝对。在算法中，有一种凭感觉解决问题的方法也成立了自己的体系 —— 贪心。&lt;/li&gt;
&lt;li&gt;贪心具有一切凭感觉解决问题的优点 —— 快速，正确率与练习的次数（刷题）成正比等等。或者说，贪心就是凭感觉解决问题的一种体现。所以，贪心的证明一般都是 &lt;em&gt;反证法&lt;/em&gt; 和 &lt;em&gt;归纳法&lt;/em&gt; 。换句话说，都是倒着推的。&lt;/li&gt;
&lt;li&gt;既然如此，那为什么我们还要讲贪心呢？&lt;/li&gt;
&lt;li&gt;其一，有些竞赛题目就是对着贪心算法设计出的，虽然运用了贪心一定还有其他解法（这只是个人观点，毕竟我看过的贪心题目大部分都可以用动态规划解决，但是动态规划解决的情况下往往更复杂），但是运用贪心可以最快的解决问题。&lt;/li&gt;
&lt;li&gt;其二，贪心作为整个逻辑体系的唯一较凭感觉的部分，可以让我们在算法学习过程中放松下大脑，在纯粹的理性中获得一些感性。这对于整体循序渐进的算法学习是有好处的（相信我，这么学到最后，你反而会觉得贪心是最有意思的）。&lt;/li&gt;
&lt;li&gt;最后，在无数日夜的反复思考中（&lt;del&gt;别误会，算法不是我女朋友&lt;/del&gt;），我找到了 &lt;em&gt;&lt;strong&gt;正着推&lt;/strong&gt;&lt;/em&gt; （&lt;del&gt;当时很激动！必须加粗 + 斜体！&lt;/del&gt;） 贪心的方法，这种正着推的方法需要的条件就是：题目本身条件+你知道它要你用贪心
&lt;ul&gt;
&lt;li&gt;难的是你怎么知道它要你用贪心？这是得靠刷题和感觉的。但是放心，我已经削减了贪心中大部分需要感觉的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是贪心&#34;&gt;WHAT: 什么是贪心？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;贪心算法，简单来说就是带着很贪心的心态解决问题。不考虑长远目标，就只看到眼前利益。把眼前利益放到最大，这就是贪心。&lt;/li&gt;
&lt;li&gt;但是贪心的最终目的还是解决长远（最终）问题。所以，你还得保证眼前利益放最大时，长远的利益也是最大。这就是贪心算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-怎么使用贪心算法&#34;&gt;HOW: 怎么使用贪心算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;贪心解题分3个步骤：（别忘了，现在学的所有方法都是位于第0节课分析问题中的 &lt;em&gt;方法选择&lt;/em&gt; 步骤）
&lt;ul&gt;
&lt;li&gt;首先，确认题目希望你用贪心（或者你也可以先试试用贪心行不行的通）&lt;/li&gt;
&lt;li&gt;然后，确认贪心的 &lt;em&gt;维度 x&lt;/em&gt; （维度需要是连续的） 和 &lt;em&gt;对象 y&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;最后，对于每个单位的维度对对象进行分析，逻辑推理这么贪心是否行的通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;很抽象，别担心，我们先不讲题目，我们用现实中的贪财来深刻理解下
&lt;ul&gt;
&lt;li&gt;一个人很贪财（他感觉钱包&lt;del&gt;题目&lt;/del&gt;想要让他贪心）&lt;/li&gt;
&lt;li&gt;他于是目光短浅，就只想今天赚最多的钱
&lt;ul&gt;
&lt;li&gt;这里， &lt;em&gt;维度 x&lt;/em&gt; 就是时间（今天）， &lt;em&gt;对象 y&lt;/em&gt; 就是钱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;于是他开始逻辑推理，如果他每天都赚最多的钱放到钱包里，那么长久来讲他的钱应该最多吗？可惜他找到了逻辑漏洞：如果有一天我把钱投资出去，得到的回报会更多。因此贪心是不行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尽管在这个例子中贪心算法失效，但是也很好的展示了如何使用贪心算法解决问题。就像这个例子一样，如果选择贪心必然会可能出现失效，但是及时止损，改变方法就行了 —— 况且贪心的逻辑推理一般也不会浪费很多的时间。所以如果对于是否使用贪心还是没感觉或者不确定，那就试试好了。&lt;/li&gt;
&lt;li&gt;现在我们对贪心有了大概的概念，贪心又是要靠刷题培养感觉的，我们就来看看部分具体的体型和题目吧 —— 背包问题和区间问题（接下来默认第一步已完成：你已经知道题目要你贪心了）。&lt;em&gt;注：这里的题目分类是从《算法竞赛入门经典》（刘汝佳）获得灵感，但是书上对于部分题目的讲解是倒着推的，因此我将在这里展示如何正着推导分析问题&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;背包问题&#34;&gt;背包问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分数问题：有 n 个物品，第 i 个物体的重量为 w_i ，价值为 v_i ，物体可切割，每件物品重量与价值成正比。在总重量不超过 C 的情况让价值尽可能高。
&lt;ul&gt;
&lt;li&gt;维度 x ：重量，对象 y ：价值&lt;/li&gt;
&lt;li&gt;对于每个重量，只要取得是性价比（重量价格率）最高，当前价值最高的即可。这么取到最后的重量必然背包装的东西价值最高，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整数问题
&lt;ul&gt;
&lt;li&gt;有 n 个物品，第 i 个物体的重量为 w_i ，不可切割。在总重量不超过 C 的情况让选的物品尽可能多。
&lt;ul&gt;
&lt;li&gt;维度 x ：物品数，对象 y ：重量&lt;/li&gt;
&lt;li&gt;对于每一个物品，只要当前的重量最小即可节省最多空间（空间利用率最高），那么最后选的物品必然会尽可能多，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有 n 个物品和无数个背包，每个背包能装下一个或两个总重量不超过 C 的东西。求最少要用几个背包装下所有东西。
&lt;ul&gt;
&lt;li&gt;维度 x ：背包数，对象 y ：重量&lt;/li&gt;
&lt;li&gt;对于每个背包，只要当前的重量装的越满（空间利用率最高），节省的空间就越多，在尽量少的空间内可以装的东西就越多。最终所用的空间或背包就越少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大家应该可以总结出了：对于每一个维度 x ，对对象 y 进行贪心。最终的结果最好时，贪心成立。我们的维度 x 可以说重量，物品数，背包数。因此寻找维度 x 和对象 y 尤为关键，接下来我们来看一看更为抽象的区间问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;区间问题&#34;&gt;区间问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;安排问题：有一批活动 a_i 从 o_i 号开展到 f_i 号。部分活动的举办日期有重叠，但且一个活动一旦开展，必须开展完毕才能开展下一个活动。要求在 N 日内开展尽量多的活动。
&lt;ul&gt;
&lt;li&gt;维度 x ：日期，对象 y ：活动数&lt;/li&gt;
&lt;li&gt;对于从第一天到当天，要尽可能开展多的活动，就要赶快开展下一个活动，也就是上一个活动就得早点结束。再推导下，越早结束的活动越优先安排。如果对于每天都能找到当天结束的活动，安排下一次活动最终能够安排的活动最多，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查问题：有一批已经安排好的活动 a_i 从 o_i 号开展到 f_i 号，部分活动的举办日期有重叠。要求设立最少的检查时间点，能够检查到每一个活动。
&lt;ul&gt;
&lt;li&gt;维度 x ：日期，对象 y ：检查点&lt;/li&gt;
&lt;li&gt;对于从第一天到当天，要检查点越少，就最好硬把检查点拖得越晚越好 —— 因为这样还有可能能检查到下一个活动，一举两得。最晚什么时候呢？当然你再晚不可能也不检查你本来需要检查的那些活动 —— 你需要检查的那些活动中最早结束的那天。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;练习&#34;&gt;练习&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;这里就不再布置练习了，因为作为感性的解决方案需要多而杂的贪心问题的练习。大家可以自行在洛谷上选择 &lt;code&gt;贪心&lt;/code&gt; tag 自行练习。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
