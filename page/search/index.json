[{"content":"WHY Why do I want to switch from Windows to Linux? First and foremost, Linux is OPEN-SOURCE. Actually, I am an OPEN-SOURCIST. It is my hope to fully stand for open-source community.\nI am able to fully customize my system. Windows have limited a large amount of options to make system fit for us. Take system fonts for example. In Linux, we could just open the config file and fill in the font we want. But in Windows, we have to deal with lots of random and unknown services to change only a system font, and then we will get a number of bugs that we cannot solve for the unknown source code.\nI am able to fully maximize my efficiency. If I want to install tools, I could just simply type $ sudo pacman -S ${pachage} or $ sudo apt install ${pachage}, and those packages\u0026rsquo; licenses like MIT, GNU are easy to follow. But in Windows, it is time-consuming to download, depackage, install, agree to license, pay for the software, etc.\nI am able to debug by my self. If we encounter a bug, we could just look at the source code and fix the bug. We could also PR to the repos and improve the software together. But for some software in Windows, it is hard to figure out how the software runs.\nWe have a large community to solve problems. In Linux, I have solved all bugs and run system smoothly without asking for any help - almost all problems and questions I encountered have been solved in Linux communities or forums.\nI am able to uninstall the services I do not want. In Linux, we are able to install whatever we want and uninstall (remove) whatever we do not want. But in Windows, there are so many services like SMB file transfer that I might not want to use for entire life! The total storage of Pure Arch Linux with Xfce and daily working and gaming software is below 8 G!\nWhy do I want to switch from Ubuntu to Arch? After using Ubuntu for several months, I have the ability to work smoothly with terminals and have basis understanding of Linux. I want to step in further, and installing Arch Linux is a good approach to that.\nArch have the most complete wiki that we might be able to solve all problems there!\nArch Linux has more universal package manager and various packages from different system (it might be AUR).\nUbuntu still have lots of services I do not know. And gnome is an anti-lightweight desktop environment which could be very annoying.\nUbuntu with gnome is stepping in commercial and be less community-friendly. And there are some ads of Ubuntu Pro appear in the system.\nWhy do I want to install Arch Linux without the script? Learn more about Linux and fully customize for myself Why do I want to switch from Gnome to Xfce Xfce is a more lightweight Desktop Environment (or Common Environment) and it will use less RAM and CPU, which are able to make my laptop battery life longer (about 8~12 hours for normal use).\nXfce is clean and easy to customize. You can install lots of plugins for Xfce and make it like Gnome or KDE but have less CPU use than Gnome and KDE. And it is cleaner as well.\nWAT Here is an introduction of Arch Linux from its wiki: https://wiki.archlinux.org/title/Arch_Linux\nHOW N.B.1. This guide is just a simplification, clarification and modification based Arch Linux-Installation Guide. If you have any questions or if I not mention or skip about some necessary steps, you could just read the wiki and find out the answer. By the way, this guide is more focusing on understanding Linux system and how a system could be installed in a machine.\nN.B.2. Every command begin with $ meaning it is a shell command. $ is always input automatically that you do not need to type it again. E.g. $ mount /dev/?{nvme0n1p4} /mnt you might only need to type in mount /dev/?{nvme0n1p4} /mnt. #, [iwd]#, etc. is also similar to $.\nN.B.3. Everything with ?{ } meaning that you could modify it based on your situation, for example $ mount /dev/?{nvme0n1p4} /mnt might be $ mount /dev/sd1 /mnt for you. Everything with !{ } meaning that you could not to type this based on your situation. E.g. $ arch-chroot /mnt !{/bin/bash} you might only need to run $ arch-chroot /mnt.\n1. Preparation A target machine that you want to install system to. A computer with 16 GB or above disk and AMD or Intel CPU is recommended. (P.S. High RAM is highly recommended. In this guide, I would not introduce how to create SWAP partition because my 16 GB RAM is enough for daily use.)\nA USB flash drive (storage device) that could be modified. A USB with 8 GB or larger is recommended.\nAn available network that is able to access to Arch Linux packages. (If you are a Chinese User, this post is recommended to use.) An unhidden network is recommended.\n2. Making an Installation Medium Windows User\nSelect one release from https://geo.mirror.pkgbuild.com/iso/ that is ending with .iso or just download the standard release from https://geo.mirror.pkgbuild.com/iso/2023.06.01/archlinux-x86_64.iso Install Rufus for installing installation image. Plug in your medium and using Rufus to install. Reboot with your medium and enter BIOS or UEFI. Select the installation medium and get into Arch Linux installation and select the first option. Linux User\nSelect one release from https://geo.mirror.pkgbuild.com/iso/ that is ending with .iso or just download the standard release from https://geo.mirror.pkgbuild.com/iso/2023.06.01/archlinux-x86_64.iso $ dd if=${Path_to_ISO} of=/dev/?{Your_medium} bs=4M Reboot with your medium and enter BIOS or UEFI. Select the installation medium and get into Arch Linux installation and select the first option. 3. Network Configuration N.B. The installation medium have installed iwd tool. Although networkmanager is more popular in Arch Linux network settings, iwd is the default network settings tool for installation.\n# iwctl to enter iwd tool. [iwd]# device list to check your network device. You need to remember your device name and type into ?{wlan0} in the following commands. [iwd]# station ?{wlan0} get-networks to check your networks and remember your SSID to type into following ${SSID} [iwd]# station ?{wlan0} connect ${SSID} to connect to SSID, you might need to type password after connect to it. [iwd]# exit to exit the network tool. # hwclock --systohc --utc and # timedatectl set-ntp true to update your system time to installation medium time. 4. Disk Mounting and Installation N.B. Mounting disk partitions to installation medium enable we to modify partitions through installation medium. You need to prepare at least two partitions - one at least 150 M as your starting partition and another above 16 G is recommended for your main Arch Linux System.\n# fdisk -l to check your partitions of disk. # mkfs.ext4 /dev/?{nvme0n1p4} to format a partition to ext4 file system for your main Arch Linux System Installation. If you want to install Dual-systems, do not run the following commands: # mkfs.vfat -F32 /dev/?{nvme0n1p1} to format a partition to fat32 file system for the boot partition. # mount /dev/?{nvme0n1p4} /mnt # mkdir -p /mnt/boot # mount /dev/?{nvme0n1p1} /mnt/boot to connect disk partitions to the installation medium. # lsblk to check your mounting situation. If this not meet your condition, you could modify by # unmount /dev/?{nvme0n1p4} /mnt command. # pacstrap /mnt base !{base-devel} ?{linux} linux-firmware e2fsprogs !{ntfs-3g} ?{vim} to install basis Arch Linux. base-devel contains makepkg that is necessary for installing AUR packages. You can install the linux kernels that you want through https://wiki.archlinux.org/title/kernel. linux-firmware is necessary Linux kernel firmware. e2fsprogs is for configuration of ext4 file system. ntfs-3g is for configuration of NTFS (Windows File System) file system. vim if for latter file editing. # genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab to generate a fstab file for Linux file tree viewing. It is safer to # cat /mnt/etc/fstab to check whether file is generated properly. P.S. Difference between \u0026gt;\u0026gt; and \u0026gt;: \u0026gt;\u0026gt; is appending (add) to the end of the file, \u0026gt; is replacing the file. 5. User Setting # arch-chroot /mnt /bin/bash to change root to /mnt (root user path) using shell in /bin/bash.\n# passwd to reset the root user password.\n# echo ?{zayn7lie-acl} \u0026gt; /etc/hostname to reset your machine name.\n# useradd -m -G wheel -s /bin/bash ${zayn7lie} set up a new user ${zayn7lie}, set it log in directory and add to wheel group. # passwd ${zayn7lie} to set user\u0026rsquo;s password. P.S. Wheel group users are used to update system (like a wheel to update continuously)\n# vim /etc/sudoers to open config file using vim. Type i to enter insert(edit) mode for vim and then find and uncomment (delete #) before %wheel ALL=(ALL) ALL. Then esc to escape from insert mode and :wq to write in (save) and quit. P.S. :wq! and :q! the ! means force. :wq! will force writing in (If the file is unchangeable, it will create a new file and replace it.), and :q! will force you to quite without any change of the file.\nvim /etc/hosts to config localhost settings. Insert:\n127.0.0.1 localhost ::1 localhost 127.0.1.1 ?{zayn7lie-acl}.localdomain ?{zayn7lie-acl} replace ?{zayn7lie-acl} with your machine name.\n6. Launch Setting # pacman -S ?{amd-ucode} grub efibootmgr to install necessary boot package. If you are using Intel CPU, change ?{amd-ucode} to intel-ucode # grub-install !{--removable} --target=x86_64-efi --efi-directory=/boot --bootloader-id=?{\u0026quot;Arch Linux\u0026quot;} --recheck to install grub file. !{--removable} determines whether you are able to remove it from UEFI, ?{\u0026quot;Arch Linux\u0026quot;} is your system name in grub. # grub-mkconfig -o /boot/grub/grub.cfg to generate config file. 7. Language \u0026amp; Time # vim /etc/locale.gen to enter language config file, then uncomment en-US.UTF-8 UTF-8 and the language you want use, then save the file. # locale-gen to generate and install language files. # echo LANG=en-US.UTF-8 \u0026gt; /etc/locale.conf to choose en-US.UTF-8 as your root user language. # ln -sf /usr/share/zoneinfo/?{EST} /etc/localtime to config your local time. ?{EST} Could be change based on your region. You can use # ls /usr/share/zoneinfo/ to check which option could be used. Some folder like ./Asia might have subfolders that you need to choose in more specific way. E.G. # ln -sf /usr/share/zoneinfo/Asia/Hong_Kong /etc/localtime. P.S. s meaning soft link which will not actually copy all file to the target folder, f meaning force to do it. 8. Xfce Installation N.B. In this section, I will just introduce how to install the cleanest and most basic Xfce with without any plugin. If you want to make Xfce better, you can read my [Xfce customization and beautification](comming soon) post.\n# pacman -S xorg to install xorg. Xorg is the basis package which contains X11 that many DE (Desktop Environment) based on. # pacman -S xfce4 to install Xfce. It is NOT recommended that you can # echo \u0026quot;exec startxfce4\u0026quot; \u0026gt;\u0026gt; /etc/X11/xinit/xinitrc to start xfce4 in the next boot and ignore step 3. It is highly recommended to install a display manager (DM) to start your system because DM will start your system more proper and create a user locker for log in as well. # pacman -S lightdm lightdm-gtk-greeter light-loceker to install this recommended lightweight DM, then # systemctl enable lightdm to let lightdm start automatically when you boot your system. You can also choose your DM. P.S. lightdm is the main DM, lightdm-gtk-greeter is for configuring your lightdm, light-loceker is for that you can lock your screen with your settings. # pacman -S networkmanager to install NetworkManager tool, then # systemctl enable NetworkManager to let NetworkManager start automatically when you boot your system. As I have mentioned above, networkmanager is more popular than iwd. And iwd is only installed in your installation medium but not your system. You still have to install a network manager tool for your Arch Linux. Finish Installation Congratulation! You have installed Arch Linux in your machine. Now you can # exit to exit your root user account, # reboot and remove installation medium when computer is completely closed. Now, start your journey to Arch Linux!\nPost-installation As I have mentioned above, if you want to make Xfce better, you can read my [Xfce customization and beautification](comming soon) post. At the same time, if you encounter any problems or bugs, reading Wiki, googling, searching in the forums or communities are both good options. But remember that if you want to ask a question, please ask in a smart way. That\u0026rsquo;s all, it is my best hope that you could join and enjoy our open-source communities!\n","date":"2023-06-20T00:00:00Z","permalink":"/posts/linux/archwithxfce/","title":"Install Arch Linux with Xfce"},{"content":"Package Pandas: import data pip install pandas import pandas as pd Class pandas.DataFrame( data, index, columns, dtype, copy) data: ndarray, series, map, lists, dict, etc. index: row index for every column columns: column index for every row dtype: data type copy: boolean type, false in default Functions Creation\npd.read_csv(): read csv as DataFrame Search\n_DataFrame.head(n) _DataFrame.tail(n): reveal n rows data _DataFrame.info() _DataFrame.describe() _DataFrame.shape(): info-type_info, describe-stat_info, shape-row_col Matplotlib Function Combined with Pandas _DataFrame.colIndex.value_counts().plot(kind='bar'): draw the data of colIndex in bar(alter: 'line', 'bar', 'barh', 'kde') plot _DataFrame.colIndex_1[_DataFrame.colIndex_2 == n].plot(kind='kde'): plot colIndex_2 == n data in colIndex_1 dimension ","date":"2023-06-07T00:00:00Z","permalink":"/posts/python/py-pydata/","title":"Data Analyzation"},{"content":"Package Matplotlib: draw data pip install matplotlib import matplotlib as plt Function matplotlib.show()： print the final figure\nmodify matplotlib.xlabel() matplotlib.ylabel() matplotlib.title() matplotlib.legend(): plot overall info ","date":"2023-06-07T00:00:00Z","permalink":"/posts/python/py-pydraw/","title":"Draw and Paint"},{"content":"Package Pytorch Scikit-learn pip install scikit-learn import sklearn Function matplotlib.show()： print the final figure\nmodify matplotlib.xlabel() matplotlib.ylabel() matplotlib.title() matplotlib.legend(): plot overall info ","date":"2023-06-07T00:00:00Z","permalink":"/posts/python/py-pyml/","title":"Machine Learning"},{"content":"Statistic(Data) Collection Observation Study Collecting Sample from Population to make inference about the Population\nMethod: SRS(simple random sample) - every individual has an equal chance: label - generate n different number - select corresponding individuals\nStratified Random Sampling: SRS individual samples from every group population Cluster Random Sampling: SRS cluster samples from cluster population Error\nSampling convenience sample overestimate underestimate voluntary response sample Non-Sampling Under coverage Nonresponse The wording of questions Experiment: prevent confounding $$ Response Variable = a \\times Factor(Explanatory Variable) + b \\times Confounding Variable(Control) $$\nMethod: Random assignment to each unit -\u0026gt; control -\u0026gt; comparisons -\u0026gt; replication\nBlind Experiment\nPlacebo Effect Census: all data collected Description One Variable Plot\nBar graph Histogram Stem plot(accurate) word\nMACRO shape/distribution uniform unimodal: skewed left/symmetric/skewed right bimodal spread: range, InterquartileRange(IQR)(resistant), StandartDeviation z-score: $z = \\frac{x - mean}{SD}$ micro Outliers: 1.5 times IQR(interquartile range) center: (mean \u0026amp;) median(resistant) gap: no data Two Variable Plot\nscatter plots word\nMACRO Direction(correlation r: -1 -(str_nag)- -0.8 - 0.8 -(str_pos) - 1) Form \u0026amp; Strength(moderately strong) micro: Outliers Regression\ns - SD of residual R-Sq (square of the correlation coefficient) - proportion of the variability that is accounted for by the linear relationship. slope-int: $b \\pm t_{\\frac{\\alpha}{2}(df = n - 2)} \\times SE_b$ Probability Distribution Discrete Distribution\ntypes\nBinomial Random Variable(P of k in n happen with A)\ncondition: B - Binomial; I - independence; N - n(trails) is certain calculator: certain x p - binompdf(; from 0 to x - binomcdf( Geometric Random Variable(P of A happen when kth in n)\ncondition: same as BRV shape: skewed right calculator: certain x p - geometpdf(; from 0 to x - geometcdf( calculation\nCombine Variable $\\bar{x} = \\bar{x_1} \\pm \\bar{x_2}$ $\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2}$ Transform Variable: $y = ax + b$ $\\bar{y} = a \\bar{x} + b$ $\\sigma_y = a \\sigma_x$ Normal Distributions(n -\u0026gt; $\\infty$, continuous)\nSampling Distribution\ncondition: CLT(Central Limit Theorem): n \u0026gt; 30, normal distribution. Estimation calculate\nconfidence level - confidence interval expression\nstate name + definition condition Independent n \u0026lt;= 10%N normal: n \u0026gt;= 30 or np, n(1 - p) \u0026gt;= 10 or draw stem plot calculation conclusion Test H_0: p = a H_0: p \u0026gt; or \u0026lt; or != a\nSample test\ncalculator input n is given: T-Test n is infty or ideal: Z-Test output: t or z: t-value or z-value p: p-value Prop test\ncalculator input: 1-PropZTest output: z: z-value p: p-value p-hat: x / n Chi-Square\nGoF(Goodness-of-Fit) Tests one dimension(Correct or not): Observed list and Expected list two dimension(df = (row - 1)(col - 1)) Independence or not: $E = \\frac{row \\cdot col}{total}$ Homogeneity or not: whether different is the same ","date":"2023-04-23T00:00:00Z","permalink":"/posts/aptest/apt-stat/","title":"Statistic"},{"content":"Extensions Markdown Markdown All in One Markdownlint Setting Config: \u0026quot;MD024\u0026quot;: {\u0026quot;siblings_only\u0026quot;: true} Markdown Preview Github Styling Latex LaTeX Workshop Setting \u0026quot;latex-workshop.latex.recipe.default\u0026quot;: \u0026quot;lastUsed\u0026quot; \u0026quot;latex-workshop.latex.recipes\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;pbpp\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;pdflatex\u0026quot;, \u0026quot;bibtex\u0026quot;, \u0026quot;pdflatex\u0026quot;, \u0026quot;pdflatex\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;pdflatex\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;pdflatex\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;latexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk (latexmkrc)\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;latexmk_rconly\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk (lualatex)\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;lualatexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk (xelatex)\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;xelatexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;Compile Rnw files\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;rnw2tex\u0026quot;, \u0026quot;latexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;Compile Jnw files\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;jnw2tex\u0026quot;, \u0026quot;latexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;Compile Pnw files\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;pnw2tex\u0026quot;, \u0026quot;latexmk\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;tectonic\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;tectonic\u0026quot; ] } ] \u0026quot;latex-workshop.latex.tools\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;-pdf\u0026quot;, \u0026quot;-outdir=%OUTDIR%\u0026quot;, \u0026quot;%DOC%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;lualatexmk\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;-lualatex\u0026quot;, \u0026quot;-outdir=%OUTDIR%\u0026quot;, \u0026quot;%DOC%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;xelatexmk\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;-xelatex\u0026quot;, \u0026quot;-outdir=%OUTDIR%\u0026quot;, \u0026quot;%DOC%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk_rconly\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;%DOC%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;pdflatex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;pdflatex\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;%DOC%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;bibtex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;bibtex\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;%DOCFILE%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;rnw2tex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;Rscript\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-e\u0026quot;, \u0026quot;knitr::opts_knit$set(concordance = TRUE); knitr::knit('%DOCFILE_EXT%')\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;jnw2tex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;julia\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-e\u0026quot;, \u0026quot;using Weave; weave(\\\u0026quot;%DOC_EXT%\\\u0026quot;, doctype=\\\u0026quot;tex\\\u0026quot;)\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;jnw2texminted\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;julia\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-e\u0026quot;, \u0026quot;using Weave; weave(\\\u0026quot;%DOC_EXT%\\\u0026quot;, doctype=\\\u0026quot;texminted\\\u0026quot;)\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;pnw2tex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;pweave\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-f\u0026quot;, \u0026quot;tex\u0026quot;, \u0026quot;%DOC_EXT%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;pnw2texminted\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;pweave\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-f\u0026quot;, \u0026quot;texminted\u0026quot;, \u0026quot;%DOC_EXT%\u0026quot; ], \u0026quot;env\u0026quot;: {} }, { \u0026quot;name\u0026quot;: \u0026quot;tectonic\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;tectonic\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;--synctex\u0026quot;, \u0026quot;--keep-logs\u0026quot;, \u0026quot;%DOC%.tex\u0026quot; ], \u0026quot;env\u0026quot;: {} } ] LTeX \u0026quot;ltex.dictionary\u0026quot;: { \u0026quot;en-US\u0026quot;: [ \u0026quot;Zayn\u0026quot;, \u0026quot;BlazEndeR\u0026quot; ] } \u0026quot;ltex.disabledRules\u0026quot;: { \u0026quot;en-US\u0026quot;: [ \u0026quot;ENGLISH_WORD_REPEAT_BEGINNING_RULE\u0026quot;, \u0026quot;UPPERCASE_SENTENCE_START\u0026quot; ] } ","date":"2023-04-21T00:00:00Z","permalink":"/posts/misc/misc-vscode/","title":"Vscode Setting"},{"content":"Better BibTex for Zotero BibTex Style as Google Research\nEdit -\u0026gt; preference -\u0026gt; Better BibTex Citation key formula: auth.lower + year + shorttitle(1,0).lower Copy BibTex\nEdit -\u0026gt; preference -\u0026gt; Export Item Format: Better BibTex Exclude(omit) unnecessary item\nBetter BibTex -\u0026gt; Export -\u0026gt; Fields Fields to omit: abstract, urldate, file, annotation, langid Zotero Citation Counts Manager ","date":"2023-04-21T00:00:00Z","permalink":"/posts/misc/misc-zotero/","title":"Zotero Setting"},{"content":"Differentiation WHY Difference between differentiate $\\frac{\\Delta y}{dx}$ and derivative $y'$\ndifferentiate is a method to cut source function to know the tendency derivative is that kinds of tendency. At (when), the rate at which (how) is increasing/decreasing by (what) (unit).\nAnalyzing f is increasing/decreasing/constant on $[a, b]$ Analyzing points Critical point: $f\u0026rsquo; = 0 \\ or \\ \\nexists f'$ Stationary point: $f\u0026rsquo; = 0$ Relative/Local Extrema: $f\u0026rsquo; = 0 \\ and \\ f\u0026rsquo;\u0026rsquo; \\neq 0$ Inflected point: $f\u0026rsquo;\u0026rsquo; = 0$ expression: concave upward(\u0026gt;0)/downward(\u0026lt;0) WHT: Differentiability If and only if $\\lim_{x → a^+}f(x) = \\lim_{x → a^-}f(x)$, $\\lim_{x → a}f(x)$ exists and equals $\\lim_{x → a^+}f(x) = \\lim_{x → a^-}f(x)$.\nIf and only if $\\lim_{x → a}f(x) = f(a)$, we say $f(x)$ is continuous at $x = a$.\nIVT (Intermediate Value Theorem): If $f(x)$ is continuous on $[a, b]$, $\\exists a, f(a) \\in [a, b]$.\nMVT (Mean Value Theorem): If $f(x)$ is continuous and differentiable on $[a, b]$, $\\exists a, f\u0026rsquo;(a) = \\frac{f(b) - f(a)}{b - a}$ EVT (Extreme Value Theorem): If $f(x)$ is continuous, and it is a close interval on $[a, b]$, $\\exists a, b, f_{max} = f(a), f_{min} = f(b)$ Discontinuity\nRemovable ~: $\\lim_{x → a}f(x) \\neq f(x)$ Infinite ~: $\\lim_{x → a^+}f(x) or \\lim_{x → a^-}f(x) = \\pm \\infty$ Jump ~: $\\lim_{x → a^+}f(x) \\neq \\lim_{x → a^-}f(x)$ If and only if $f(x)$ is continuous at $x = a$ and $lim_{b → 0^+}\\frac{f(a + b) - f(a)}{b} = \\lim_{b → 0^-}\\frac{f(a + b) - f(a)}{b}$ or $\\lim_{b → 0}\\frac{f(a + b) - f(a)}{b}$ exist, $f(x)$ is differentiable at $x = a$.\nep. $f\u0026rsquo;(x)$ not exist while $lim_{x → a}f\u0026rsquo;(x) = \\pm \\infty$\nHOW: Differentiating Approximation when use the tangent line at $x = a$ to approximate $f(b)$:\n$$ f(b) = f(a) + f\u0026rsquo;(a)(b - a) $$\nBasic $$ (f \\pm g)\u0026rsquo; = f\u0026rsquo; \\pm g\u0026rsquo;, \\ (f \\cdot g)\u0026rsquo; = f\u0026rsquo; \\cdot g + f \\cdot g\u0026rsquo;,\\ (\\frac{f}{g})\u0026rsquo; = \\frac{f\u0026rsquo; \\cdot g - f \\cdot g\u0026rsquo;}{g^2}, \\ RelatedRate: (f(g(x)))\u0026rsquo; = f\u0026rsquo;(g(x)) \\cdot g\u0026rsquo;(x) \\ or \\ \\frac{\\Delta f}{dx} = \\frac{\\Delta f}{dg} \\cdot \\frac{\\Delta g}{dx} $$\nImplicit \u0026amp; Explicit $$ Implicit \\ form: (xy = 1)\u0026rsquo; → (y + y\u0026rsquo;x = 0) → y\u0026rsquo; = - \\frac{y}{x} \\ Explicit \\ form: (y = \\frac{1}{x})\u0026rsquo; → y\u0026rsquo; = - \\frac{1}{x^2} $$\nInverse $$ (arcsin/cos{x})\u0026rsquo; = \\pm \\frac{1}{\\sqrt{1 - x^2}} \\ (arctan{x})\u0026rsquo; = \\frac{1}{1 + x^2} $$\nL\u0026rsquo;Hospital Rule When exist fraction with $0$ or $\\infty$, we use following rule: $$ \\lim_{x → a}\\frac{f(x)}{g(x)} = \\lim_{x → a}\\frac{f\u0026rsquo;(x)}{g\u0026rsquo;(x)} $$\nIntegration WHY Function Area Slope Fields Arc Length $$ L = \\int_a^b{\\sqrt{dx^2 + \\Delta{y}^2}} = \\int_a^b{\\sqrt{1 + (\\frac{\\Delta{y}}{dx})^2}{dx}} $$\nHOW Approximating\nTrapezoidal Sum: $\\sum_{i = 0}^{n - 1}{\\frac{(f(x_i) + f(x_{i + 1})) \\cdot \\frac{b - a}{n}}{2}}$ Riemann Sum left/right/mid-end: every rectangular\u0026rsquo;s left/right/mid above point start at the curve right-end: $\\sum_{i = 1}^{n}{f(x_i) \\cdot \\frac{b - a}{n}} \\ or \\ \\sum_{k = 1}^{n}{f(a + k \\cdot \\frac{b - a}{n}) \\cdot \\frac{b - a}{n}}$ Integral: $\\int_{a}^{b}f(x)dx = lim_{n → \\infty}{\\sum_{k = 1}^{n}{f(a + k \\cdot \\frac{b - a}{n}) \\cdot \\frac{b - a}{n}}}$ Euler\u0026rsquo;s Method: $x_{i + 1} = x_i + step, y_{i + 1} = y_i + step \\cdot f,(x_i, y_i)$ Basic\nSimilar to Differentiate $$ \\int_a^b{f(x)dx} = - \\int_b^a{f(x)dx} \\ \\int_a^b{f(x)dx} = \\int_a^c{f(x)dx} + \\int_c^b{f(x)dx} $$\nSubstitution: multi-functions with its derivative function Remember to separate variables\n$$ \\int{f(g(x)) \\cdot \\frac{\\Delta}{dx}g(x) dx} = f,(g(x)) + C $$\nIntegration by Parts: complex function(from simple derivative) multiply another complex function(its derivative function is simple) $$ \\int{f(x) \\cdot g\u0026rsquo;(x)}{dx} = f(x) \\cdot g(x) \\mid_{a}^{b}- \\int{f\u0026rsquo;(x) \\cdot g(x)}{dx} $$\nSequence WHY ","date":"2023-04-16T00:00:00Z","permalink":"/posts/aptest/apt-calbc/","title":"Calculus"},{"content":"Electricity Micro Force: Coulomb\u0026rsquo;s Law $$ |\\vec{F_E}| = \\frac{1}{4 \\pi \\epsilon_0} |\\frac{q_1 q_2}{r^2}| = \\vec{E} \\cdot q $$\n$q_1$ \u0026amp; $q_2$ (Charge): Positive (Glass + Silk) Negative (Plastic + Fur) electrons: neg (e) Protons: pos (e) neutrons \u0026amp; atoms: neutral Field (Reason of Force): Gauss\u0026rsquo;s Law $$ \\Phi_E(Flux) = \\oint{\\vec{E}}{d\\vec{A}} = \\frac{Q}{\\epsilon_0} \\ Q = \\begin{cases} \\int{\\lambda}{dL} \\ \\int{\\sigma}{dA} \\ \\int{\\rho}{dV} \\end{cases} $$\n$\\oint{\\vec{E}}$ (Gaussian Surface): enclosing with sphere or cylinder Sphere: $\\frac{Q}{\\epsilon_0 \\cdot 4 \\pi L^2}$, non-conducting (L \u0026lt; r): $\\frac{Q L}{\\epsilon_0 \\cdot 4 \\pi r^3}$ Cylinder (wire): $\\frac{\\lambda}{\\epsilon_0 \\cdot 2 \\pi L}$ Plate: $\\frac{\\sigma}{\\epsilon_0 \\cdot 2}$ Potential (Energy of Force) $$ W_{a → b} = -\\Delta{U}, U = k \\frac{q q_0}{r} \\ V = \\frac{U}{q} = k \\frac{q}{r} = E \\cdot r $$\nEquipotential Surfaces Macro Kirchhoff\u0026rsquo;s Rules Current rule: for every junction, exists $I = \\sum{I_i}$\nVoltage rule: for every loop, exists $0 = \\sum{V_i}$\nConductors Charge distribution: surface, $\\propto$ curvature Electric field: inside = 0, surface: vertical Potential: inside: same Capacitors $$ C = \\frac{(\\kappa) \\epsilon_0 A}{d} = \\frac{Q}{\\Delta{V}} $$ $Q$: only one plate; $\\kappa$: vacuum = 1, others \u0026gt; 1\nother shape: $C = \\frac{Q}{E d}$\nRelationship with time (RC Circuit)\n$$ Charging: \\ \\epsilon - i R - \\frac{q}{C} = 0, i = \\frac{d}{dt}{q} \\ q = C \\epsilon(1 - e^{-\\frac{t}{R C}}) \\ \\ Discharging: \\ -\\frac{q}{C} - i R = 0, i = \\frac{d}{dt}{q}, q = Q_0 e^{-\\frac{t}{RC}} $$ $\\tau = R C$ when $t = \\tau$, $q = (1 - \\frac{1}{e})Q_f$\nMagnetism Micro Fields (Reason of Force)： Ampere\u0026rsquo;s Law enclosed loops Macro Inductance RL Similar to RC $$ -i R - L \\frac{d}{dt}i = 0, i = I_0 e^{-\\frac{t}{L / R}}, \\tau = L / R $$\nOther things could be similar to Electricity\n","date":"2023-04-16T00:00:00Z","permalink":"/posts/aptest/apt-phyce/","title":"Electricity and Magnetism"},{"content":"Motion and Force Basis $$ v = \\frac{d}{dt}x, a = \\frac{d}{dt}v, F = m \\cdot a \\ \\bar{v} = \\frac{s}{t} = \\frac{v_0 + v}{2}, 2a\\Delta{x} = v^2 - v_0^2 \\ $$ $x = \\vec{Displacement}(vector)$ $s = Distance(scalar)$\nForce Type: Normal Force $n$, Friction $f$, Tension $T$, Weight $w$, Resistive Force v-t relation when Resistive Force exists(v(0) = 0) $$ N2L: F = ma = mg - kv, \\frac{a}{g - \\frac{kv}{m}} = 1 \\ \\int_0^t{\\frac{a}{g - \\frac{kv}{m}}}{dt} = \\int_0^t{1}{dt} , \\int_0^t{-\\frac{m}{k} \\cdot \\frac{-\\frac{k}{m} \\cdot \\frac{d}{dt}v}{g - \\frac{k}{m}v}}{dt} = t \\ -\\frac{m}{k} \\cdot ln(g - \\frac{k}{m}v) \\mid_0^t = t, ln(1 - \\frac{k}{mg}v(t)) = -\\frac{kt}{m} \\ 1 - \\frac{k}{mg}v(t) = e^{-\\frac{kt}{m}}, v(t) = \\frac{mg}{k}(1 - e^{-\\frac{k}{m}t}) $$\nEnergy $$ W = \\vec{F} \\cdot \\vec{s}, P = \\frac{d}{dt}W = \\vec{F} \\cdot \\vec{v} \\ Restoring \\ Force: W = \\int_{x_1}^{x_2}{-kx}{dx} = \\frac{1}{2}k(x_1^2 - x_2^2) \\ Work-Energy \\ Theorem: K = \\frac{1}{2}mv^2, W_{net} = \\Delta{K} \\ Potential \\ Energy: \\Delta{U_g} = m\\vec{g}\\vec{\\Delta{x}}, U_s = \\frac{1}{2}k\\Delta^2{x} \\ CoME_{Conservation \\ of \\ Mechanical \\ Energy}: \\Delta{E_{mech}} = K + U $$\nMomentum and Impulse $$ \\vec{p} = m \\vec{v}, \\vec{J} = \\int{F}{dt},J = \\Delta{p} \\ Collision(Elastic): v_1 = \\frac{m_1 - m_2}{m_1 + m_2}v_1, v_2 = \\frac{m_1 + m_1}{m_1 + m_2}v_1 $$\nUniversal Gravitation $$ G M = v^2 r = g r^2, \\frac{T^2}{r^3} = \\frac{4 \\pi^2}{G M} $$\nRotation and Torque Similar to Motion and Force\nBasis $$ Parallel-axis \\ Theorem: I = I_0 + M \\Delta^2{d} \\ Rod: \\frac{1}{12} M L^2 \\ Sphere: \\frac{2}{5} \\ Disk: \\frac{1}{2} \\ Hollow: \\frac{2}{3} \\ Hoop: 1\\ $$\nSynthesize $$ Rolling \\ without \\ slipping: v_{cm} = r \\omega (\\alpha, \u0026hellip;) \\ Energy: \\frac{K_{\\omega}}{K_v} = \\frac{\\frac{1}{2} I \\omega^2}{\\frac{1}{2} m v^2} = \\frac{\\frac{I}{r^2}}{m} \\ Momentum: \\tau \\cdot \\Delta{t} = \\Delta{L}, \\vec{L} = \\vec{r} \\times \\vec{p} $$\n","date":"2023-04-16T00:00:00Z","permalink":"/posts/aptest/apt-phycm/","title":"Mechanics"},{"content":"ps. Algorithm is too simple in AP CSA, and there are some similar grammar between java and c++. So I just conclude some basic java grammar instead of all knowledge points in AP testing.\nClass creation Normal Access modifier (AM) private: can only access in current object and cannot be inherited public: can access in all situation and be inherited public class ClassName{ // extends superClass{ // instance variables private String name; // \u0026lt;AM\u0026gt; \u0026lt;Type\u0026gt; \u0026lt;Variable name\u0026gt;; public int data; // constructors public ClassName(int initialValue1, String initialValue2){ // super(iVFromsuperClass) data = initialValue1; name = initialValue2; } // if there is another parameter public ClassName(int initialValue1){ // super(iVFromsuperClass) data = initialValue1; name = \u0026#34;default user\u0026#34;; } // a class could with different constructors // this called overloading // methods public void methods(int para){ return; } public String getName(){ return name; } } Inheritance superClass -inheritance-\u0026gt; subClass public class ClassName extends superClass{ // instance variables private String name; // \u0026lt;AM\u0026gt; \u0026lt;Type\u0026gt; \u0026lt;Variable name\u0026gt;; public int data; // it will inheritance public (and protected) variables from superClass public static int count; // static = global variable, if publie, use count through `ClassName.count` instead of `objectName.count` // constructors public ClassName(int initialValue1, String initialValue2){ super(iVFromsuperClass) data = initialValue1; name = initialValue2; } // methods public void methods(int para){ return; } public String getName(){ return name; } public String toString(){ super.toString(); return name; } // toString is from superClass Object // this is called overriding // in following methods (super cannot be access outside class) toString() is different from super.toString() } public class A{ public void a(); } public class B extends A{ public void a(); public void b(); } A ob1 = new A(); A ob2 = new B(); ob1.a(); // a method from A ob2.a(); // a method from B (override memory) ob1.b(); // CE ob2.b(); // CE (memory omit) ob2 = ob1 // 修改地址的赋值而不是赋值内容 All class is the subclass of Object class public class Object{ public Object{ ; } public String toString(){ // could be overrided and access directly through ClassName(); } public Boolean equals(Object other){ // return true if object address equals to other // String override this method that return true when content is equals to other instead of address } } Class application Object type VariName (= initial) or class VariName = new class()( or subclass())\ntype primitive types: int / double / boolean (true/false) int: ± 2^31 - 1 Reference types: String / Integer / Double / Boolean String index being from 0 null cannot call a method(null.equals \\\\error) -\u0026gt; null null is including in address final variable = const in c++ I.e. Math() cannot be constructed, only can be use through Math.method() Method print: System.out.print(\u0026quot;String\\n\u0026quot;); calculate then output: System.out.print(7 + 8 + (7 + 8) + \u0026quot;Hello\u0026quot; + 7 + 8 + (7 + 8)) -\u0026gt; \u0026quot;30Hello7815\u0026quot; creation public class FileName{ public static type funcName(type paraName){ return; } public static void main(String[] args){ type result = funcName(); System.out.print(result + \u0026#39;\\n\u0026#39;); return; } } Special Class - Array initialize Class[] value = new Class[n]; \\\\ null is inside Class[] value = {a, b, c, d}; \\\\ a b c d is address\ntraversing for(int i = 0; i \u0026lt; value.length; i ++) \\\\ no \u0026quot;()\u0026quot; for(int i : value) \\\\ not change the value just let i equal value\nSpecial Array ArrayList (= vector in c++)\ncreation: ArrayList\u0026lt;referenceType\u0026gt; VarName = new ArrayList\u0026lt;referenceType\u0026gt;(); 2D Arrays\ninitialize int[][] value = new int[n][m]; int[] value = { {1, 2}, {3, 4}}; traversing(row-major) for(int i = 0; i \u0026lt; value.length; i ++) for(int j = 0; j \u0026lt; value[0].length; j++) ","date":"2023-04-14T00:00:00Z","permalink":"/posts/aptest/apt-csa/","title":"OOP (Objected-Oriented Programming)"},{"content":"WHY: 为什么学排序相关的算法？ 实际上，我们学排序并不是因为排序本身，毕竟 c++ 本身已经又自己的排序函数 std::sort(头指针，尾指针，（规则）) 位于 \u0026lt;algorithm\u0026gt; 头文件中。而且这个排序一般比我们自己写的时间复杂度更低。 我们学排序是为了对前面的基础算法有一个回顾，加深算法的印象，更好的掌握好基础算法，才能在接下来的学习中更顺利。 WHAT \u0026amp; HOW 我并不打算讲排序有关内容，因为前人已经整理的很完整了： OI WIKI: SORT 如果后面突然又什么好的理解会再更新重写的。 ","date":"2023-03-05T00:00:00Z","permalink":"/posts/algorithm/alg-01basis-04sort/","title":"从0开始的算法竞赛01-算法基础04：排序"},{"content":"WHY: 为什么要学贪心算法？ 我相信大家愿意跟着我建立算法和 c++ 体系的原因是体系的逻辑性及减少凭感觉解决问题，这也是本博客的目的。但是，凡事没有绝对。在算法中，有一种凭感觉解决问题的方法也成立了自己的体系 —— 贪心。 贪心具有一切凭感觉解决问题的优点 —— 快速，正确率与练习的次数（刷题）成正比等等。或者说，贪心就是凭感觉解决问题的一种体现。所以，贪心的证明一般都是 反证法 和 归纳法 。换句话说，都是倒着推的。 既然如此，那为什么我们还要讲贪心呢？ 其一，有些竞赛题目就是对着贪心算法设计出的，虽然运用了贪心一定还有其他解法（这只是个人观点，毕竟我看过的贪心题目大部分都可以用动态规划解决，但是动态规划解决的情况下往往更复杂），但是运用贪心可以最快的解决问题。 其二，贪心作为整个逻辑体系的唯一较凭感觉的部分，可以让我们在算法学习过程中放松下大脑，在纯粹的理性中获得一些感性。这对于整体循序渐进的算法学习是有好处的（相信我，这么学到最后，你反而会觉得贪心是最有意思的）。 最后，在无数日夜的反复思考中（别误会，算法不是我女朋友），我找到了 正着推 （当时很激动！必须加粗 + 斜体！） 贪心的方法，这种正着推的方法需要的条件就是：题目本身条件+你知道它要你用贪心 难的是你怎么知道它要你用贪心？这是得靠刷题和感觉的。但是放心，我已经削减了贪心中大部分需要感觉的部分。 WHAT: 什么是贪心？ 贪心算法，简单来说就是带着很贪心的心态解决问题。不考虑长远目标，就只看到眼前利益。把眼前利益放到最大，这就是贪心。 但是贪心的最终目的还是解决长远（最终）问题。所以，你还得保证眼前利益放最大时，长远的利益也是最大。这就是贪心算法。 HOW: 怎么使用贪心算法？ 贪心解题分3个步骤：（别忘了，现在学的所有方法都是位于第0节课分析问题中的 方法选择 步骤） 首先，确认题目希望你用贪心（或者你也可以先试试用贪心行不行的通） 然后，确认贪心的 维度 x （维度需要是连续的） 和 对象 y 最后，对于每个单位的维度对对象进行分析，逻辑推理这么贪心是否行的通 很抽象，别担心，我们先不讲题目，我们用现实中的贪财来深刻理解下 一个人很贪财（他感觉钱包题目想要让他贪心） 他于是目光短浅，就只想今天赚最多的钱 这里， 维度 x 就是时间（今天）， 对象 y 就是钱。 于是他开始逻辑推理，如果他每天都赚最多的钱放到钱包里，那么长久来讲他的钱应该最多吗？可惜他找到了逻辑漏洞：如果有一天我把钱投资出去，得到的回报会更多。因此贪心是不行的。 尽管在这个例子中贪心算法失效，但是也很好的展示了如何使用贪心算法解决问题。就像这个例子一样，如果选择贪心必然会可能出现失效，但是及时止损，改变方法就行了 —— 况且贪心的逻辑推理一般也不会浪费很多的时间。所以如果对于是否使用贪心还是没感觉或者不确定，那就试试好了。 现在我们对贪心有了大概的概念，贪心又是要靠刷题培养感觉的，我们就来看看部分具体的体型和题目吧 —— 背包问题和区间问题（接下来默认第一步已完成：你已经知道题目要你贪心了）。注：这里的题目分类是从《算法竞赛入门经典》（刘汝佳）获得灵感，但是书上对于部分题目的讲解是倒着推的，因此我将在这里展示如何正着推导分析问题 背包问题 分数问题：有 n 个物品，第 i 个物体的重量为 w_i ，价值为 v_i ，物体可切割，每件物品重量与价值成正比。在总重量不超过 C 的情况让价值尽可能高。 维度 x ：重量，对象 y ：价值 对于每个重量，只要取得是性价比（重量价格率）最高，当前价值最高的即可。这么取到最后的重量必然背包装的东西价值最高，贪心成立。 整数问题 有 n 个物品，第 i 个物体的重量为 w_i ，不可切割。在总重量不超过 C 的情况让选的物品尽可能多。 维度 x ：物品数，对象 y ：重量 对于每一个物品，只要当前的重量最小即可节省最多空间（空间利用率最高），那么最后选的物品必然会尽可能多，贪心成立。 有 n 个物品和无数个背包，每个背包能装下一个或两个总重量不超过 C 的东西。求最少要用几个背包装下所有东西。 维度 x ：背包数，对象 y ：重量 对于每个背包，只要当前的重量装的越满（空间利用率最高），节省的空间就越多，在尽量少的空间内可以装的东西就越多。最终所用的空间或背包就越少。 大家应该可以总结出了：对于每一个维度 x ，对对象 y 进行贪心。最终的结果最好时，贪心成立。我们的维度 x 可以说重量，物品数，背包数。因此寻找维度 x 和对象 y 尤为关键，接下来我们来看一看更为抽象的区间问题。 区间问题 安排问题：有一批活动 a_i 从 o_i 号开展到 f_i 号。部分活动的举办日期有重叠，但且一个活动一旦开展，必须开展完毕才能开展下一个活动。要求在 N 日内开展尽量多的活动。 维度 x ：日期，对象 y ：活动数 对于从第一天到当天，要尽可能开展多的活动，就要赶快开展下一个活动，也就是上一个活动就得早点结束。再推导下，越早结束的活动越优先安排。如果对于每天都能找到当天结束的活动，安排下一次活动最终能够安排的活动最多，贪心成立。 检查问题：有一批已经安排好的活动 a_i 从 o_i 号开展到 f_i 号，部分活动的举办日期有重叠。要求设立最少的检查时间点，能够检查到每一个活动。 维度 x ：日期，对象 y ：检查点 对于从第一天到当天，要检查点越少，就最好硬把检查点拖得越晚越好 —— 因为这样还有可能能检查到下一个活动，一举两得。最晚什么时候呢？当然你再晚不可能也不检查你本来需要检查的那些活动 —— 你需要检查的那些活动中最早结束的那天。 练习 这里就不再布置练习了，因为作为感性的解决方案需要多而杂的贪心问题的练习。大家可以自行在洛谷上选择 贪心 tag 自行练习。 ","date":"2023-03-04T00:00:00Z","permalink":"/posts/algorithm/alg-01basis-03greedy/","title":"从0开始的算法竞赛01-算法基础03：贪心"},{"content":"WHY: 为什么要关注时间和空间 想象你面前有两个程序可以实现你的目的。 A 程序需要 1 GB 的内存来运行且要跑1个小时才能得出答案， B 程序需要 1 KB 内存需要跑1秒钟得出答案，你会选择哪个程序。很显然， B 程序。 不仅如此，算法竞赛中大多都会限制你所使用的空间（内存）和时间。并且往往时间的限制更严格（毕竟现在 CPU 等硬件可以不断的扩大内存，但是时间仍然对人类很宝贵）。 那我们怎么测量时间和空间呢？ —— 时间复杂度和空间复杂度 WHAT: 什么是时间复杂度和空间复杂度 我们先来看一个函数： void run1(int n){ printf(\u0026#34;execute \u0026#34;); for(int i = 1; i \u0026lt;= n; i ++) printf(\u0026#34;execute \u0026#34;); for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt; = n; j ++) printf(\u0026#34;execute \u0026#34;); for(int a = 1; a \u0026lt;= n; a ++) for(int b = 1; b \u0026lt;= n; b ++) for(int c = 1; c \u0026lt;= n; c ++) printf(\u0026#34;execute \u0026#34;); } 运行一次这个程序要多久？很显然，要进行 $1 + n + n^2 + n^3$ 次操作。相比一个要进行 run2(n) $n + n^2 + n^3$ 的程序一定更慢，相比 run3(n) $1 + n + n^2$ 当n不为0时也更慢。 我们来考虑两种情况，当n很小（趋近0）时，显然 $run2 \u0026lt; run3 \u0026lt; run1$。当n很大时（趋近正无穷）时， $run3 \u0026lt; run2 \u0026lt; run1$ 。那如果你要选一个程序来跑，你会选择 run2 还是 run3 ？ 也许你会反应过来，当n很小时，虽然run2更快，但是大家本身都很快，run3也许运行个1ms，run2只运行0.99999ms，但我哪感受的出来？而且如果有个时间限制，run2和run3一定都不会超出限制。但是n很大的时候，run2因为三次方的数量级增长的很快，一下就会慢run3很多。所以我们都会选择run3来运行。 通过这个例子，大家会有一个模糊的概念，我们关注时间的时候往往关注的是最高次方（或者增长最快的哪一项），因为我们在评价程序快慢的时候只有在 n 很大的情况下评价才有意义， n 很小大家速度都差不多，是没什么意义的。所以我们就创造了一个符号来表示程序运行的最高次项（或增长最快的项） - $O$ ，称为时间复杂度。例如run1和run2的时间复杂度为 $O(n^3)$ ，run3的时间复杂度为 $O(n^2)$ 这下谁快谁慢就显而易见了。 知道了时间复杂度，那空间复杂度是什么？还记得例如递归的函数里面套函数吗？当函数运行一半跑去运行另一个函数时，这个函数还没返回值就会先占用一定的内存。另外你用的参数越多，占用的内存也越多。比如你开一个 10^9 的数组一定比开 10 的数组占用的空间多。因此我们知道空间复杂度和调用的函数深度（函数里面调用函数的次数，每次就像往深处又探了一点）与参数的使用相关。那计算公式呢？其实不太重要。因为你只要注意这两点基本上就不再会遇到空间不足的问题了 —— 毕竟正如上面所说，竞赛重时间轻空间。并且这里还可以回顾上章所说为什么如果递归的回归没有加限制条件往往会爆内存 —— 函数无线的深探下去，占用的内存越来越多，最终导致 CPU 内存占满程序运行错误。 HOW: 怎么测量时间复杂度？怎么优化时间复杂度？ 测量时间复杂度的测量 根据上面的例子，我们可以知道时间复杂度只与最高次项有关，那次项间怎么对比呢？我们来看这组关系： $$ 1 \u0026lt; \\log{n} \u0026lt; n \u0026lt; n \\cdot \\log{n} \u0026lt; n^2 \u0026lt; n^2 \\cdot \\log{n} \u0026lt; \\dotso $$\n这么多实际上只要知道 $1 \u0026lt; \\log{n} \u0026lt; n$ 即可，剩下的自己组合相乘。 1 用在正常的语句，没有枚举循环递归等等，最正常最快的时间复杂度。有些人会有为什么不是2，3之类的疑惑（当有2个或3个语句）。实际上，这些系数都是搭配常数，不影响整体的上升趋势，比起趋向无限大的n时均可忽略不计，常数无论搭配哪种系数绝对比不过一次二次的n。同理，如果操作次数为 $2 \\cdot n$ 我们也仍写作 $O(n)$ 。 n 就是正常只有一个循环就是 $O(n)$ ，循环里套一个循环娃就是 $O(n^2)$ ，循环里套的娃再套一个娃就是 $O(n^3)$ $O(\\log{n})$ 的时间复杂度实际上在上一节课枚举中找已经排好的元素中是否存在某个元素就出现过。大家发现我们每次提出中间然后一分为二，不断的一分为二（专业称为二分）就创造出了 $\\log_{2}{n}$ 次操作。但是底数2仍然只是个常数，因为 $\\log_{2}{n} = \\frac{\\log_{a}{n}}{\\log_{a}{2}}$ 其中 $\\log_{a}{2}$ 作为常数不影响整体趋势，因此我们直接写成 $\\log{n}$ 即可。 有二分就有倍增，倍增也是可以将 $O(n)$ 优化为 $O(\\log{n})$ 的一种常用手段。倍增的理解这里就不再提及了，有一篇很好的理解方式推荐给大家：倍增与兔子的故事 那 $n \\cdot \\log{n}$ 应该也不难理解：循环里套一个二分就是 $O(n \\cdot \\log{n})$ 剩下的都是一样的道理，至于一些我们没见过的时间复杂度会在后面遇到的时候再讲。 时间复杂度的优化和前缀和 大家发现我们没有提到空间复杂度，还是那句话，现代 重时间轻空间 。因此，我们往往会牺牲空间复杂度来减小时间复杂度，或者说 拿空间换时间 。这节课我们会介绍拿空间换时间的典型例子 —— 前缀和。 我们先看下这道题目：已知数组储存有 n 个数，求 t 次第 a 个数到第 b 个数所有数的和（对于每次 a, b 不相同）。 正常的思路就是从 a 一个一个加到 b ，因此会写出这样的程序： int sum(int* vector, int a, int b){ int ans = 0; for(int i = a; i \u0026lt;= b; i ++) ans += vector[i]; return ans; } 先问问大家这个程序运行一次的时间复杂度是多少？很容易回答： $O(b - a)$ 。但是是错误的，正确答案是 $O(n)$ 。注意，我讲时间复杂度的时候一直在强调上升趋势，大家发现我 b - a 的限制只会与 n 相关，当 n 越大， b - a 的范围可以越大，换句话说，上升的比例和 n 成正比。所以，正确答案是 $O(n)$。如果调用这个函数的次数为t，那么总时间复杂度为 $O(t \\cdot n)$ 。也许你还不是很理解，但没关系，我们接下来会遇到大量对于时间复杂度的考虑和计算，你也会对时间复杂度有更深刻的了解。 一般来说，枚举都可以进行优化，那这个可不可以进行一些优化（我们接下来课程说的优化一般都将重心放在时间复杂度的优化）呢？照样，我们不会像某些竞赛教练先告诉大家有前缀和然后逆推到结论：前缀和能优化时间复杂度，我们照样按照逻辑正着推。大家发现，我能优化的点只有在这个循环上 —— 毕竟你不能改变函数的调用次数。那怎么优化呢？还记得我们可以 拿空间换时间 ，那么我希望能够先储存一定的信息，然后通过这个信息能够直接快速的得出 a 到 b 的和。那我要储存什么信息呢？什么信息能够在不破坏（不加深）时间复杂度的情况下提前储存和的信息？首先我们可以分析（化简和拆分）这个问题 —— 怎么处理从 a 开始的和 + 怎么处理到 b 结尾的和。然后推导公式 —— 两边如果都添上一个从0开始的和，那就有 a 到 b 的和 = 0到b的和 - 0到a - 1的和。那我们的数组需要储存的信息就是从0到x的和即可（$O(n)$）（我只要储存一次即可），剩下需要访问的话就直接把 vector[b] 和 vector[a - 1] 相减即可（$O(t \\cdot 1)$）总时间复杂度 $O(n + t) \u0026lt; O(t \\cdot n)$ 。因此，我们用一个数组（空间），储存了一些关键信息，成功的化简了时间复杂度。因此程序变成这样： 前缀和数组构建： int vector[n + 2], sum[n + 2] = {0}; void construct(){ for(int i = 1; i \u0026lt;= n; i ++){ sum[i] = sum[i - 1] + vector[i]; } return; } 主要函数就变成这个样子： int sumFromAToB(int a, int b){ return sum[b] - sum[a - 1]; } 用数组储存信息化简时间复杂度是一种非常重要的化简方法，在后面线段树、并查集等等都会用到。希望大家能够好好掌握前缀和，掌握这种用空间换时间很基本的方法。我们在今天的练习中还会对前缀和进行拓展，希望大家完成后认真的学习一下题解，相信对大家以后的优化程序能力会有很大提升。 练习 KN luogu-P1115 最大子段和（运用前缀和） 40分基本要求 100分需要优化遍历：想想哪些步骤是没有必要的？ 40分主要代码：（a是前缀和数组） int f(int* a){ int ans = -1e5; for(int i = 1; i \u0026lt;= n; i ++) for(int j = i; j \u0026lt;= n; j ++){ // [i, j]这个区间之和 ans = ans \u0026gt; a[j] - a[i - 1] ? ans : a[j] - a[i - 1]; // 比较大小，相当于 ans = max{ans, a[j] - a[i - 1]} } return ans; } 100分代码 int f(int* a){ int ans = -1e5; for(int i = 1; i \u0026lt;= n; i ++) for(int j = i; j \u0026lt;= n; j ++){ ans = ans \u0026gt; a[j] - a[i - 1] ? ans : a[j] - a[i - 1]; if(a[j] - a[i - 1] \u0026lt;= 0) // 优化 break; } return ans; } 这里解释下为什么有这个优化。首先我们脑中模拟一遍这个程序，寻找是否存在不必要的操作，可以发现当 a[i] 小于等于 0 时，无论 i + 1 到 j 的和多大， i 到 j 的和必然小于 i + 1 到 j 的和，因为 i 到 j 的和相当于 i + 1 到 j 的和加上了个小于等于0的数仍然小于等于 i + 1 到 j ，因此其中必然不会有更大的值，就直接跳过了。 学完动态规划，你会发现即使时间复杂度已经化简到很小了，连空间复杂度还可以再次化简。 US 已知二维数组(n, m)储存有 $n \\cdot m$ 个数，求t次第$(x_a, y_a)$ 个数到第 $(x_b, y_b)$ 个数所有数的和（对于每次 a, b 不相同）。 提示：如果没思路可以先自行了解下 容斥原理 再尝试。 sum 数组构建： int vector[n + 2][m + 2], sum[n + 2][m + 2]; void construct(){ for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= n; j ++) sum[i][j] = vector[i][j] + (sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]); // 括号里的内容及运用容斥原理 return; } 主要函数： int sumFromAToB(int x_a, int y_a, int x_b, int y_b){ return sum[x_b][y_b] - sum[x_b][y_a - 1] - sum[x_a - 1][y_b] + sum[x_a - 1][y_a - 1]; // 仍然是容斥原理 } MT luogu-P2367 语文成绩 提示：既然有前缀和，那为什么不能有前缀差（专业名称：差分）呢？ 因为差分的思路和前缀和及其相似，这就不过多解释了，详情请见 题解 US+MT luogu-P3664 Modern Art / usaco-17UopP1 Modern Art ","date":"2023-03-03T00:00:00Z","permalink":"/posts/algorithm/alg-01basis-02timespace/","title":"从0开始的算法竞赛01-算法基础02：时间和空间"},{"content":"递归(Recursion) WHY: 为什么要学递归？ 首先我们先明确，算法其实是另外一种形式的数学 —— 它们解决问题的思路很相近，及通过一系列的计算得出结果。但是在计算机的帮助下，算法能干更多数学干起来很麻烦的事情 —— 一些重复、模板性的问题。 而递归，作为算法的第一课，便很好的体现出算法和数学的异同之处。递归，可以化简大量的重复性问题。因此学会递归，我们便可以利用计算机化简许多问题的运算过程。 可能不太好理解，没关系，我们先往下看看递归是什么。 WHAT: 什么是递归？ 我们先来看下这个函数公式： $$ f(x) = \\begin{cases} 0, \u0026amp; x \\leq 7 \\ f(x - 1), \u0026amp; x \u0026gt; 7 \\ \\end{cases} $$\n很显然，当 $x \\leq 7$ 的时候 $f(x)$ 均等于0。但是当 $x = 10$ 的时候呢？ $f(10) = f(9) = f(8) = f(7) = 0$ 当 $x \u0026gt; 7$ 的时候有没有一种感觉，就是这个 $f(x)$ 的 $x$ 一直在 传递 到下一个 $f(x)$ ，只是自身每次减一？ 当 $x = 7$ 时， $f(x)$ return 0时候有没有一种感觉这个0在不断 回归 到 $f(10)$ ? 这种 传递 和 回归 的感觉就叫做 递归 。或者说， 递归 = 传递 + 回归 很多教材喜欢举一些很有趣但是对初学者很不友好的例子： 想要知道递归，就得先知道递归 ， 自己调用自己 等等。但是经过我利用上面数学公式的举例，相信你能看得懂这些玩笑了。实际上，这些例子都是在强调 $f(x) = f(x - 1)$ 的过程。但这只是 传递 的过程。 另外，通过这里例子，我们还可以加深算法与数学异同的理解。数学遇到这种公式一般需要转化为其他公式（就想上面的展开 $f(10) = f(9) = f(8) = f(7) = 0$ 等等）再求解，这其实如果数据一大，公式一复杂，求解就会变得困难。而算法，正盼望着你把问题转化为这种 自己调用自己 形式，那剩下的求解呢？交给计算机就可以了。 HOW: 递归怎么写？ 递归分为传递和回归，传递就是往下的方式，回归就是限制条件回来的过程。很抽象，我们还是看刚刚那个公式： $$ f(x) = \\begin{cases} 0, \u0026amp; x \\leq 7 \\ f(x - 1), \u0026amp; x \u0026gt; 7 \\ \\end{cases} $$\n这里传递就是 $f(x) = f(x - 1)$ ，方式就是 $x$ 自己减一。 回归的限制条件是 $x \\leq 7$ 。 如果这些都能理解，我再告诉你个条件。在程序函数中，是可以自己调用自己的，那即使你只学过我 0基础c++体系-函数 的第一节课应该可以写的出来这个函数： int f(int x){ if(x \u0026lt;= 7) return 0; if(x \u0026gt; 7) return f(x - 1); } 这就是递归函数该怎么写。虽然内容较少，但是递归将伴随整个算法生涯，甚至后面递归我们不会再强调，而是把它当作一种和加减乘除一样常见的方法。所以希望本节课大家能好好理解。特别是注意写递归时不仅要有传递，还要有回归（限制条件要写清楚）。如果没有限制条件或者条件不当，程序将无限运行下去，知道内存超标。 枚举(Enumeration) WHY: 为什么要学枚举 和递归类似，枚举也是让计算机帮助我们列举情况，找到我们要求的解。掌握枚举也可以让我们再调试和运行时提高一定的效率。 WHAT: 什么是枚举 实际上，在你学 for(;;) 和 while() 的时候，你已经开始接触枚举了。我们当时只不过是通过循环把每一种情况列举出来，这就叫枚举。但是枚举的方式不仅仅只有循环，想本章的递归也可以作为枚举的一种方法。 HOW: 怎么写枚举 循环：关于循环的枚举已经在 c++ 基础讲完了。所以这里就强调下注意循环的对象，开始，终点和步长。 实际上，循环的枚举往往是可优化的。例如在一个从小到大排列的数组中询问某个数是否存在的时候，往往可以从中间开始列举。如果比中间的数大，则应该在右侧寻找，及对右侧再进行相同操作；如果比中间的数小，则对左侧进行相同操作。直到找到这个数或者是发现这个数在最终两个数之间 —— 不存在。 这种不断一分为二缩小范围寻找答案的方法叫做二分，是一种常用的枚举优化方法。 递归：刚刚的样例已经包含了递归 —— 如果比中间的数大，对右侧进行相同操作 —— 这个相同操作就是递归中的传递。有时候，循环和递归是可以互换的。例如你可以用循环实现刚刚的操作： bool find(int* vector, int target){ int l = 0, r = sizeof(vector) / sizeof(vector[0]) - 1; // r 为数组的右指针 while(vector[l] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= vector[r]){ int m = (l + r) / 2; if(vector[m] == target || vector[r] == target || vector[l] == target) // 预先看下左边界有边界是否相等，避免遗漏 return true; else if(vector[m] \u0026lt; target) l = m; else if(vector[m] \u0026gt; target) r = m; } return false; } 当循环和递归可以同时实现的时候，更推荐用循环的形式。因为递归在传递还未回归的时候那些传递过程中的函数在计算机运算时需要存起来（想想为什么），可能导致内存占用变高。 最后希望各位能够认真完成这节课 US 和 MS 的 GCD 和 LCM ，其困难在许多体制内学生并不认识辗转相除法。大家自行了解后尝试解决，对于本节课可以有更深的了解。 这节课内容虽少，但是对于之后的学习非常重要。因此我会在 ANS 对于每道题目做出较详细的讲解。希望大家无论是否做出来了也认真的看完题解。 练习 KN 请写出一个函数 A(x, y) ，要求返回 x 中取 y 个元素进行排列的所有种类数。 请写出一个函数 C(x, y) ，要求返回 x 中取 y 个元素进行组合的所有种类数。 想想能不能进行优化？ 我们先来讲讲排列组合怎么算 从 x 中选取 y 个进行排列，那么我们就对 y 中的每个元素进行枚举：第一个元素一共有 x 种选法，第二个元素一共有 x - 1 种选法，第三个元素一共有 x - 2 种选法\u0026hellip; 第 y 个元素一共有 x - y + 1 种选法。因此一共有 $x(x - 1)(x - 2) \\dotsm (x - y + 1)$ 种选法。通过阶乘我们还可以表示成更简单的方法 $\\frac{x!}{(x-y)!}$。这就是排列。 而对于组合，实际上就是把排列中的部分情况去除掉： ABC, ACB, BAC \u0026hellip; 在组合中是相同的，因此只保留一个。那么一共有多少种相同的情况呢？如果再观察可以发现，每一种情况相当于是自己本身的排列。 ABC, ACB, BAC \u0026hellip; 实际上就是 ABC 的 A(3, 3) 的排列。所以再原来基础上只要再除掉一个 A(y, y) 就是正确答案了。那么可以表达为 $\\frac{x!}{y!(x - y)!}$ 那么第一反应的程序是这个样子的： int A(int x, int y){ int ans = 1; // ans = answer for(int i = 1; i \u0026lt;= x; i ++) ans *= i; for(int i = 1; i \u0026lt;= x - y; i ++) ans /= i; return ans; } int C(int x, int y){ int ans = 1; for(int i = 1; i \u0026lt;= x; i ++) ans *= i; for(int i = 1; i \u0026lt;= x - y; i ++) ans /= i; for(int i = 1; i \u0026lt;= y; i ++) ans /= i; return ans; } 可以化简，因为我们知道组合是排列的除掉部分情况的结果，直接调用 A 函数即可： int C(int x, int y){ int ans = A(x, y); for(int i = 1; i \u0026lt;= y; i ++) ans /= i; return ans; } 分析可以知道， A 乘和除掉了一部分相同内容，我们不要枚举除掉的部分其实就可以达到效果了。因此对 A 再化简： int A(int x, int y){ int ans = 1; for(int i = x - y + 1; i \u0026lt;= x; i ++) ans *= i; return ans; } 这验证了我们上面所述，枚举一般都可以进行优化。当然这里只是对枚举的过程优化，实际上我们学到后面还会学到直接对整个枚举这个方法进行优化等等。 US 请写出一个函数 GCD(x, y) ，要求返回 x 和 y 的最大公因数。 luogu-P1888 三角函数 接下来我们来说一说 GCD （最大公因数）怎么算 首先我要拿辗转相除法说下“正着推”和“反着推”的区别和好坏 很多人了解辗转相除法的公式，但是问为什么的时候，教练一般从辗转相除法的公式入手，有的运用假设法（假设辗转相除法不成立），有的运用从公式开始推导到条件法等等。这些实际上都是反着推。他们先知道了结论才给你推的出来。这其实不叫“为什么”，这个叫“怎么证明”。换句话说，“反着推”就是如果你不知道这个公式你就推不出来，你必须先知道，先背住这个公式才推的出来。这个好处就是很快，你都背住了竞赛直接用即可。但是很容易忘，而且遇到没见过的也推不出来。 是不是觉得在哪里见过？没错，在我讲第0节课“凭感觉”和“靠分析”的时候出现过“速度”和“准确”的区别。其实“逆着推”也可以算作一种凭感觉的解决方法问题。我也讲过理科竞赛讲究的不是感觉而是分析。那么“正着推”作为靠分析的手段，我们怎么“正着推”辗转相除法？ 首先我们要求 x 和 y 的最大公因数 z ，那么我们知道的条件是 $x = z \\cdot a, y = z \\cdot b (z, a, b, x, y \\in Z)$ 那么我们有两条路，一条是继续推导公式，一条是拆分或化简问题。因为现在是独立的两个条件，而我们需要的是一个通解，这时候我选择继续推导公式，将这5个变量联系在一起。因此有 $x - y = z \\cdot (a - b)$ 通过推导和观察我们发现，z也是(x - y)的因数（我们假设 $x \u0026gt; y$）。但是(x - y)必定比x, y都小，因此，z又是y和(x - y)的GCD。有什么意义呢？大家发现，这一步我其实化简了问题：把两个很大的数开始变小，并且这两个较小数和原来的两个较大的数有联系并经过了 相同操作 。相同操作 ，对，有没有发现什么 —— 递归！计算机给了我么另外一个思路，把公式转化相同形式的运算也可以！那么我们得出了一个结论：$GCD(x, y) = GCD(y, x - y)$。脑中模拟一边过程，发现那么只要这么一直重复下去x, y一定会越来越逼近0（因为x, y一定一直减小），在等于0的前一刻呢？x必然等于y, 因为x - y才等于0。那这时候x = y这个值不就是原来的GCD(x, y)吗？ 接下来我们看看能不能优化。因为过程中出现了很多次x - y，当x很大时必然会减很多次y，这产生了很多操作。那能不能化简呢？就是让x减去最多的y但是仍然大于0？很多人想到了 —— 模运算！ $x \\mod y$ 就是操作了最多次x - y的结果！那么我们就优化出了这个公式 $GCD(x, y) = GCD(y, x \\mod y)$ 这就是辗转相除法（因为模运算涉及除法的余数） 这就是正着推的辗转相除法，从条件推导公式而不是从公式推导条件！相信这么推一次大家印象一定很深刻。即使以后忘记只要记着遇见条件想办法进行 推导 ， 拆分 和 化简 就能得出正确答案！ 因此递归公式得到后，程序就好实现了： int GCD(int x, int y){ if(y \u0026gt; x){ //让x \u0026gt;= y，统一化 int tmp = x; x = y; y = temp; } if(y == 0) // 递归的回归条件 return x; return GCD(y, x % y); } 相信写完这个程序大家能够对递归有着更深刻的了解。 MT 请写出一个函数 LCM(x, y) ，要求返回 x 和 y 的最小公倍数。 luogu-P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题 推完了 GCD ，大家可以自己想想很相似的 LCM 。这里只要注意因为类似排列和组合相似性， LCE 和 GCD 的公式会存在关联。大家可以自己尝试下正推。我这里给出函数： int LCM(int x, int y){ return x * y / GCD(x, y); } ","date":"2023-03-02T00:00:00Z","permalink":"/posts/algorithm/alg-01basis-01recursionenumeration/","title":"从0开始的算法竞赛01-算法基础01：递归和枚举"},{"content":"WHY: 为什么要分析算法问题？我怎么知道我是分析还是凭感觉？ 如果你真的有这种疑惑，那么你大概率平时是靠感觉解决问题的 —— 我并不是说我们并不能靠感觉解决问题的，且凭感觉解决问题也是很重要的一项技能（凭感觉解决问题其实并不是什么不好的方式，其实就是第六感），凭感觉有着速度快、和经验正相关的精准等优点。但是作为理科竞赛，我更希望凭感觉少些，分析的成分多些。这样在你一些从没有遇到类型的问题你也可以得出正确答案。 WHAT: 什么是凭感觉？什么是靠分析？ 凭感觉准确是指一眼看题目便能不经过任何考虑便知道怎么解决，一个很简单的例子就是 7 * 7 = ？ ，你能够直接回答出乘法口诀表七七四十九。而不是分析：拆分成7个7进行相加。这就是我对凭感觉的定义。另外一个突出的例子就是网上各大媒体流传的《秒杀高考/中考题目》的各种技巧。很显然，凭感觉的最突出优点就是快。但是当问题复杂时（条件不足、没有见到）很容易就没法得出正确答案。 分析就是形成一套万能的体系机器，无论是什么问题输入机器后通过机器内的逻辑加工都能的出正确答案。例如我在写每一章知识时都将知识拆分成 WHY WHAT HOW ，这便是 分析 中的 拆分 。当然，因为它的通用性导致它的速度肯定不如凭感觉。但是它是最稳定的正确答案输出器，且符合理科竞赛的靠逻辑本质。所以我将在本章详细将如何分析一个算法题目。 HOW: 怎么分析一道理科题目？ 首先，一道理科题目一般由这几个部分组成： 背景 主体 数据 样例 。 我们来看这个样例： # Farmer John(FJ) 的奶牛很喜欢学习，他们看到FJ学了编程也想参与其中，但是在阅读编程书籍的时候出现了问题。 # 这本编程书籍一上来就要求编译一个程序计算 a + b 的值。但是他们才第一天学，什么都不知道。请问你可以帮助他们写一个样例吗做个示范吗？ # 输入一行a和b，用空格隔开。 # 输出一行，输出 a + b 的值。 # 样例：输入：1 1 输出：2 # 数据范围：0 \u0026lt; a, b \u0026lt; 10^9 我们来分析下这个样例： 背景：第一行就是背景了（该样例虽然是我自己编的，但是以后看到 Farmer John 和奶牛就可以猜是 USACO 的题目，这毕竟是他们题目背景的特色）。该背景基本上没啥用，就是放松下，顺便彰显下作为理科生毫无编故事能力。基本可以直接跳过。 主体：主体在第三行，主体也经常会和背景混杂在一起。对于主体，我们要会提取关键信息。关键信息一般是提出的问题，例如这里“帮助写样例”是关键，而什么样例 —— “a + b 程序” 也成了关键。关键信息的提取一般需要经过训练培养感觉，不要浪费太多时间。 数据：为什么主体问题提取不要浪费太多时间？因为即使关键提取的较为模糊，数据也会帮你把关键信息打磨干净。这里数据位于4、5和最后一行 —— 包含了输入输出和范围。就算你主体的关键信息没提取清楚，看到输出你也清楚了 —— 就是一个输出 a + b 的程序嘛。至于范围，一般都是在题目的最后。你一般需要利用范围选择合适的结构和数据类型来解决问题。 样例：样例一般是作为测试的数据。它一般较为简单，方便你调试。用于写完写程序时的模拟和程序后的检验。 我们已经知道了一个题目的结构，接下来就是分析解决问题了： 建立模型：就是把实例问题数学化。就类似我们一般会把鸡兔同笼问题转化为二元一次方程一样，这就是模型的建立。 模拟\u0026amp;拆分： 模拟：我们在心里模拟一边代码的大致运行路程，或者说模拟就是题目说什么我们就写什么不做任何优化。例如题目说有一组背包，每个背包重多少时，我们就建立一个数组，把这个数组用来储存背包重量，题目说每个背包减轻了30kg，我们就把数组的每个元素都减30\u0026hellip; 实际上模拟虽然很多教练都特别提出来讲，但是其实没有什么必要 —— 我们每道题实际上都有用到模拟，只是多数情况下在脑中模拟而已。 拆分：在模拟过后，我们对程序有了个大致的框架想法，这时候就可以把一个大问题拆分成几个小问题了。先把简单的问题解决，难的问题再经过后续步骤得出方案。（更系统的拆分叫做 分治 ，这里就不细说了，有兴趣可以自己了解下。 分治 还特意加入了合并步骤，更加的科学合理。） 方法选择：对于每个子问题选择最优的方案。实际上，我们接下来讲的各种递归，二分等都是方法，运用在这一步骤。 代码转化：将方案转化为代码。 复杂度优化：最后分析是否有更好的结构、方法可以提高代码速度、减少占用空间。 当然，这种分析只是一个框架，具体问题仍需具体分析。但是，当我们将每个问题放到这个框架中，便可以越来越熟悉，将框架转化为一种习惯或者说感觉。最终达到准确率和速度都提升的效果。 ","date":"2023-03-01T00:00:00Z","permalink":"/posts/algorithm/alg-01basis-00introtoalgorithm/","title":"从0开始的算法竞赛01-算法基础00：你真的会分析算法问题吗？"},{"content":"WHY: 为什么我们要使用头文件？ 上节课我们已经了解了函数的结构及作用。实际上，存在这各种各样奇奇怪怪且复杂的函数，例如 打印函数 printf() 。 int printf (const char *__format, ...){ int __retval; __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format ); __retval = __mingw_vfprintf( stdout, __format, __local_argv ); __builtin_va_end( __local_argv ); return __retval; } 该函数的作用就是我们上节课提及的 输出 或者 打印 函数。而且这一段只是函数的主题部分，还有各种涉及计算机底层端口的各种调用和参数。 如果我们需要使用自己写一遍绝对是非常没有效率的行为。而且如果真的要求记忆这么大段内容这就不是理科竞赛的目的了。因此， c++ 已经帮我们写好了，而我们只需要通过一些小 tricks 就可以调用这些函数了 —— 使用头文件。 WHAT: 什么是头文件？ 存储了一些函数的文件，方便我们编写程序。 一般放在需要调用头文件程序（或函数）的头部（开始）。 HOW: 怎么使用头文件 #include\u0026lt;cstdio\u0026gt; //调用头文件\u0026lt;cstdio\u0026gt; 该头文件里包含 printf() 函数 int main(){ printf(\u0026#34;Hello, world!\u0026#34;); //\u0026#34;Hello, world!\u0026#34;打印出来/输出到终端（屏幕） return 0; } 接下来课程，我会在程序中使用 // 添加注解方便大家的理解，这些 // 之后的同行内容将被编译器忽略。相似的注解方式还有 /* 注解内容 */ 等。 我们发现上面的程序多了个 #include\u0026lt;cstdio\u0026gt; ，头文件的调用就是简简单单通过 #include\u0026lt;头文件\u0026gt; 来进行的。 大家发现我们并没有定义 printf() ，实际上这个函数已经被定义在 cstdio 头文件里了，所以我们是可以直接使用该函数的。 标准输入输出函数 接下来，我们将沿着 printf() 这个重要的函数，讲一讲输入和输出的方法。 WHY: 为什么存在输入输出，还需要“标准”？ 输入相当于我们把我们的需求输入计算机，计算机最终返回我们需要的结果。 输入设备和输出设备千奇百怪，什么都有。例如文件输入，终端输入等等。这些输入输出的格式也不一样 因此，我们需要让程序有统一的输入和输出格式和设备。 WHAT: 那什么是标准输入输出呢？ 标准输入输出是全由终端进行输入和输出的一种方式。 HOW: 怎么进行输入输出？ 首先，我要先说明，我并不推荐有些教练所述通过输入输出流进行输入输出（ \u0026lt;iostream\u0026gt; //input ouput stream 中的 std::cin 和 std::cout）因为它太 臃肿 了，在使用不当的情况下会拖累程序运行。 我推荐的是源自 c 语言的 \u0026lt;cstdio\u0026gt; //c standard input ouput 中的 scanf() 和 printf() 函数。 我们上面已经知道这两个函数需要调用 \u0026lt;cstdio\u0026gt; 函数，那我们这里会详细的将这两个函数该怎么用： printf(): scanf(): ","date":"2023-02-26T00:00:00Z","permalink":"/posts/c++/cpp-02headfile/","title":"从0开始的C++语言基础02：头文件"},{"content":"WHY: 为什么不应该先学“Hello, world”？ 我相信更多人想问为什么从函数讲起，而不是从\u0026quot;Hello, world\u0026quot;讲起。原因很简单： Hello, world 这个程序太“难”了。 我知道很多人对“难”很有意见。先别急，对于学过的人自己想想，当时在第一次看 Hello, world 代码时是不是一头雾水？并且被要求死记硬背？ #include\u0026lt;cstdio\u0026gt; int main(){ printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } 或者\n#include\u0026lt;iostream\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 你一定会问： include 是干什么用的？什么是 namespace ？为什么要写 int main() ？\u0026hellip; 这时候教练会说：你先记着，以后就知道了？ 不管你爽不爽，反正一上来就死记硬背我很不爽，理科竞赛应该是自己写的每一个逻辑语句都清清楚楚原理，而不是死记硬背。而且\u0026quot;Hello, world\u0026quot;之所以出名是因为方便检测 编译器 而不是 用来学习 。所以，我打算从比 Hello, world 更简单的程序说起。 先请看以下程序，这个程序是不是更简洁，不懂的地方是不是也更少？ int f(int x){ return x + 1; } 这准确来说并不是程序（虽然编译器不会报错），这是个 函数 ，等价于 f(x) = x + 1 ，这个才应该作为初学者的起点。 WHAT: 比\u0026quot;Hello, world\u0026quot;更简单的“程序” —— 函数 什么是函数？/为什么要先学函数？ 什么是函数？ 函数 （英语： Function ）是数学描述对应关系的一种特殊集合。 放心，这么抽象的定义我也看不懂，但是注意下函数的英语： Function 。对，功能。函，同含。因此你可以理解为函数就是包含了一系列功能的“数”。（ p.s. 计算机科学中的函数更偏向功能的意思，因为它削弱了 映射 的关系，加强了功能性） 举个例子： f(x) = x + 1 ， f(x) 这个函数所包含的功能就是把 x 加上1后输出。 因此，我们可以发现，所有的答案都可以转化为复杂的函数 f(g(x) + h(y) * u(z)) 等等。把这个过程实现了，就是一个程序了。 函数的重要性由此彰显，这也就是我们为什么先学函数。函数，就是程序最根本的底层逻辑。或者说， 所有的程序由函数组成 。 函数的组成 我们再回来看下这个函数：int f(int x){return x + 1;} 等价于数学中的 f(x) = x + 1。接下来，我们来彻底搞懂这个函数： int ：就相当于先告诉计算机这个 f 和 x 是整数（ integer ） (int x)： 输入的值。后面的程序可以直接 f(1) ， f(2) 的用函数，此时x等于1，2 return ：经历一系列计算最终返回的值，等价于数学中最终 f(x) 的值 ;：分隔符，把几个语句隔开来 {}：把整个函数“包”起来 此时你应该有个大概的理解了，但是可能还是有些模糊。那我们再来看下这一个更复杂的函数，我会运用比喻加深下理解： int f(int a){ int b; b = 1; a = b; a = 2 * a; b = a; return a; } 第2行：int b 语句的专业属于叫做 声明(declare) 。可以理解为计算机是一家有大，中，小胶囊房间的胶囊宾馆。我们预定了名字叫 b 的小型房间。这个房间小到只能装的下整数(int)，比如浮点数(float ，整数 + 小数)因为有尾巴（小数）因此住不下，而长整数(long long int ，可以储存更大的整数)因为太胖了也住不下，必须住大型房间。int f 和 int a 也是同理。更多的房间类型我们会在以后遇到的时候讲到。目前只要知道 int 整数就可以了。另外，这里的 int float long long int 叫做 类型（type），这里的 b f a 叫做 变量（variable） 所以，一个 declare 的语句应该是这样的： type variable; 例如 int a; 第3行：此时b房间住进了整数1。这里 = 是 住进 的意思（专有名词： 赋值运算符），并不是相等的意思，意思就是把 1 这个值赋给了 b 。 第4行：把 b 的值赋给了 a 。这里我不用住宾馆的比喻是因为如果我说 b 的 1 住进了 a 可能会引起 a 现在没人的误解。实际上此时 a 和 b 里面都是 1 。可以理解 b 里住的 1 分身的另一个 1 住进了 a。 第5行：如果充分理解了上面的内容。这里可以理解为 a 里住的人分身后乘以2（此时1 * 2 = 2）然后住回了 a 。那 a 里面原来的 1 呢？被新来的 2 赶跑替换掉了。（后来居上） 第6行： a 里的 2 分身后替换掉了 b 中的 1 ，此时 a 和 b 中住的是 2。 第7行： f(a) 最终返回的值，返回 a 中的 2 。 此时我全用专业术语讲一遍： a 输入 f 函数，b 初始化为整数，把 1 赋值给 b 。把 b 中的值赋值给 a ， a 自己乘以2，b 赋值回 a， 最终函数 f 返回 a。 如果你能看懂，那么恭喜你，你已经 c++ 入门了。可是，你可能会又疑惑，写了这么多函数，虽然没有写程序时候的报错（ compile time error(CE) ，编译时错误），但是运行时后会报错（ runtime error(RE) ，运行时错误）。那程序怎样能运行起来呢？程序又从哪儿开始呢？ 程序之主 —— main()函数 再开始前，我要补充下：函数不一定要有输入，例如数学中 f(x) = 1 作为常函数就不需要输入（虽然数学中的函数更为偏向映射的意思，计算机更偏向功能的意思）。因此写程序时可以直接写 int f(){return 1;} 而不需要写 int f(int x){return 1;} 我们来看看接下来这个程序： int f(int x, int y){ return x + y; } int main(){ int a; int b; a = 1; b = 1; int c; c = f(a, b); return 0; } 这个程序已经可以运行起来了。但是这个程序有些奇怪：没有输入也没有输出。我们来研究下这个程序： 计算机从 main() 作为主函数（程序的开头）开始运行。但为什么我们先写 f(int x, int y) 。这就像我们解答数学考卷一样，在使用函数前要先写清楚描述清楚函数。计算机从上往下读取时也得先知道有 f 这个函数，在后面调用中才知道要往上找来执行。 这里主函数 return 0 并不是说为了某个程序调用时返回0，毕竟作为主函数也没有必要返回值 —— 一般在运行中间就得到答案就可以输出了。这里的 return 0 只是告诉计算机该程序正常运行，没有出错而已。 注意此时 f 有两个输入 x(a) 和 y(b) 返回 x + y 的值。这是合法的，一个函数可以有多个输入。此时程序等效为 c = a + b (或者 c = 1 + 1) 如果可以理解了，我们就来看看这个复杂的程序： int h(int i){ return i; } int f(int i){ return h(i); } int main(){ int i = ...; f(i); return 0; } 你能说出这个程序的运行顺序吗？ main -\u0026gt; f -\u0026gt; h -\u0026gt;(此时开始返回值) f -\u0026gt; main 这有点像搭积木，我们把 main 放在最底下，然后 f 放在 main 上面，最上面放上 h ； h 输出后移走 h 露出 f ， f 输出拿走 f ，最后再到最底下的 main 这种结构，后进先出（ LIFO, Last In First Out ）（越后面进来的先输出后离开）我们称呼为堆栈（ stack ）这种结构我们后面还会提及，这里有个基本模糊的理解即可。 HOW: 怎么写一个基本的程序？ main() 框架 根据上面的内容，我们可以知道一个程序首先要写 main() 函数。 int main(){ 语句; return 0; } 我们知道 main() 的输出并不重要，那为什么我们把 main() 函数定义为整数 int ？ 在讲之前，我希望能够通过这个问题提高大家的 答案寻找能力 寻找一个问题的答案需要先 提取关键词 关键词： c++ （问题的所属领域） main （问题的对象） why declare int （问题） 然后选择提问平台 谷歌 百度 知乎 stack overflow 填入关键词进行搜索 更多的提问方法可以参考 提问的智慧 经过搜索后，你可能会找到该答案： The short answer, is because the C++ standard requires main() to return int . As you probably know, the return value from the main() function is used by the runtime library as the exit code for the process. Both Unix and Win32 support the concept of a (small) integer returned from a process after it has finished. 简单来说，就是早期 c++ 标准时候的规定，当程序返回0时运行正常。 我通过这个案例的真实目的是强调我 blog 的作用并不是 寻找答案 ，而是提供一个对于知识点可能更好的一种理解，以此提高大家学习的效率。我希望大家向我提出的问题更多是对于理解的疑惑，而不是像这个问题一样本来可以在各种平台上找到答案而偏要浪费大家的时间。 那么，现在大家会写一个函数的框架了，那么里面的具体运算呢？ Arithmetic 基础计算\u0026amp;运算符 基本的“+ - * /” 是可以直接用的，例如 a = 1 + 1, a = 1 * 1 但注意，除法仍然不能除以0，如果除以0会报RE(runtime error) 在上面我们曾提过，“=” 是赋值运算符而不是 等于 的意思。就相当于安排房间的意思。那 等于 要怎么表示呢？实际上，等于并不在基本运算里。如果你有疑惑，请注意，等于 或者 相等 实际上是一种判断， a 等于 b 并不是运算，而是一种判断，判断 a 是和 b 相等的意思。至于判断语句，我们会在后面讲解。目前只需知道 “=” 是赋值运算符即可。 接下来我们要介绍一种特殊的运算：模运算 % 模运算作为数论里重要的一部分，可惜体制内学生连数论的接触也较少。因此我会介绍下模运算，如果学过的可以直接跳过。 模是在整数运算中求一个整数 x 除以另一个整数 y 的余数的运算，且不考虑运算的商。 回忆下最初学的除法运算：8 / 5 = 1 ······ 3 这里 x = 8，y = 5 这里的 3 就是 8 mod 5 的结果 所以 8 mod 5 = 3 表达： a = b % c 还有些常见的定理，可以自行了解： (a ± b) % c = (a % c ± b % c) % c (a * b) % c = a % c * (b % c) % c 想想除法是否也可以这么用？ (a ^ b) % c = (a % c)^ b % c 想想为什么不是^(b % c)？ 总结 其实我挺纠结要不要把总结给写出来。因为总结本来是由大家自行总结并建立体系的一个环节，我希望大家能够自己总结自己学到的东西而不是一味的输入。而且每个人的总结方式有所不同。所以我可能以后会根据情况而定是否总结。 这里举例两种总结方式： Function: WHY: \u0026hellip; WHAT: \u0026hellip; HOW: \u0026hellip; Function: declare: type: int \u0026hellip; \u0026amp; name \u0026hellip; body: arithmetic: \u0026hellip; return: \u0026hellip; 总结的目的是复习自己今天所学知识，能够对自己学到东西的多少有判断并且再次复盘加深印象。每个人适合的总结方法也不同，不一定要按照上面的方式总结，自己通过搜索引擎多试几种方法，找到最适合自己的方法。 预告 我们已经学会了函数的基本写法，也知道程序的主函数 main() 在运行中已经得到答案了，最后的 return 0 只是告诉计算机程序正常运行。但是，怎么把答案输出呢？或者怎么把我们想要知道的变量里的数输出呢？这个问题，我们将在下一节得出答案。 练习 作为第一次练习，我会强调我的练习分为三种程度：知道（ know or KN ） 理解（ understand or US ） 掌握（ master or MT ） KN 练习着重于通过练习加深对于本章所讲内容的梳理，是打好基础的必要条件。做出来只能证明你认真的看完了本节内容。 US 练习对知识点进行了一定的迁移与参数的改变，是继续往下学的必要条件。做出来可以证明你在学习时有进行一定的思考和消化。 MT 练习对知识点进行深挖和探究，进行了较大的迁移，是学好 c++ 和算法的重要条件。做出来可以证明你在学习时能够内化知识并且建立自己的理解和体系。 如果 KN 练习做不出来，希望你能够重新好好的看完本节内容再做。如果 US 练习做不出来，可以好好的消化复习本节内容，并通过搜索引擎解决存在的疑惑后再次尝试。如果 MT 练习做不出来，可以对照答案思考自己所欠缺的内容，加深自己的理解后自己重新在做一遍。答案在本章最后或者下章开头。 KN 请说出下列函数中 a 的值： int f(int x){ return x * 2; } int main(){ int a = 1; a = f(a); return 0; } a = 2 US 请说出下列函数中 a 的值和运行的顺序： 提示：括号里的运算拥有较高优先级 int h(int x){ return 1; } int g(int x){ return h(x); } int f(int x){ return g(h(x)); } int main(){ int a = 1; a = f(a); return 0; } 1, main() -\u0026gt; f -\u0026gt; h(括号内的先算，直接返回值) -\u0026gt; g -\u0026gt; h -\u0026gt;（开始返回值） g -\u0026gt; f -\u0026gt; main MT 请写一个函数 f ，输入为 a, b ，交换 a, b 的值后输出 a ；(所有 type 均为 int) 提示：需要引入辅助变量 c 完成交换 int f(int a, int b){ int c = a; a = b; b = c; return a; } ","date":"2023-02-20T00:00:00Z","permalink":"/posts/c++/cpp-01function/","title":"从0开始的C++语言基础01：函数"},{"content":"基本网站的搭建 创建 GitHub 账号并登录 模板库的复制 点我 复制（ folk ） chirpy 主题的模板库 Repository name 一栏输入 用户名.github.io ，例如我的是 zayn7lie.github.io 点击 Create repository from template 生成网站后端库 模板库的配置 进入库，找到 _config.yml 并打开 在代码栏的右上角点击笔的图案，进入编辑模式 修改 title: 后的内容，为你的博客取个名字 拉到最下方，点击 Commit changes 模板库的初始化 提交完成后，在上方点击 Setting -\u0026gt; 左方 Code and automation -\u0026gt; pages -\u0026gt; 右方 Build and deployment -\u0026gt; Source 从 Deploy from a branch 换成 GitHub Actions 过一会后打开 用户名.github.io 你的博客界面就创建完毕啦 更多的设置可以自己在后端调配，本篇教程也会列出一些我自己遇到的问题和解决方案 有关 chirpy 主题的教程可以在 这里 查看 博客图标头像修改 ref 打开 Real Favicon Generator 导入你想要的图标 加载完毕，拉到最下边，点击 Generate your Favicons and HTML code 点击 Download your package: 的 Favicon package 解压，删除 browserconfig.xml 和 site.webmanifest 将图片全部上传到你的库里的 assets/img/favicons/ （如果没有就创建这样文件夹） Commit 后图标就出来啦！ 主页头标的修改在 _config.yml 的 avatar 里设置路径，例如 avatar: 'assets/img/avatar.png' ","date":"2023-02-20T00:00:00Z","permalink":"/posts/misc/misc-blogbuildinglearning/","title":"最简单的从0开始免费博客网站搭建"},{"content":"WHY: 为什么要使用编译器和搭建 C++ 环境 ~= 为什么吃饭要使用嘴巴 WHAT: 什么是编译器和 C++ 环境 本小节内容仅供有兴趣者阅读，因为本小节对于竞赛和平时使用并无太大帮助，当然在了解了编译器和环境后对以后的一些 C++ 能够有更深的理解，也有助于以后真正使用 C++ 写程序。 暂时不想写，先玩算法竞赛，本小节敬请期待。 HOW: 如何搭建 C++ 环境及编译器的选择 对于中国体制内参加 NOI 的算法竞赛生： dev-cpp 不要想花里胡哨好玩的编译器了，老老实实给我用 dev-cpp https://sourceforge.net/projects/orwelldevcpp/files/latest/download！ 该软件是全国统一的竞赛软件（ for c++ ），因此你即使掌握了再多各种软件和各种功能，考试的时候还是得使用 dev-cpp ，那为什么不一开始就使用这个软件呢？ 点击上方即可下载，不要下载最新版。一方面全国的机考都是用该版本 dev-cpp ，另一方面最新版 dev-cpp 已闭源商用。开源就是最好的，那么闭源就是最差的，因此不要用最差的闭源软件。（个人喜欢拿逻辑开玩笑，别介意） 下载完安装（如果连安装都不会的话就一路点 next 就行） 该软件会帮你直接安装好编译器并且搭建好 C++ 环境 点击左上角空白的纸打开新的一页，写完程序按f11即可保存并运行。 其他的竞赛生（线上考生）： vs-code 编译器下载 一律推荐使用 vs-code https://code.visualstudio.com/download 首先，这个软件比 dev-cpp 更好用，但是也会更麻烦。因此怕麻烦的话也可以使用上面的 dev-cpp 。 如果你决定使用 vs-code ，那么恭喜你，你将获得一个可以使用一生的软件。 vs-code 支持所有语言，你还可以把它当作一个 txt 阅读器，上面还有一堆插件，你甚至可以把它折腾成一个 all in one 的软件。 下载完后安装，没什么需要强调的，上面默认勾选的已经足够正常使用了（如果连安装都不会的话，请仔仔细细看完每个页面的内容，选择自己的需求，然后点击下一步。如果你不愿意那么麻烦的话，那不太建议你使用 vs-code ，可以使用上面 dev-cpp ，毕竟安装连使用的第一步都算不上） 打开之后在最左边侧栏点击积木（插件 extentions ），搜索框输入 c++ ，找到并点击由 microsoft 发布的 C/C++，之后在右边主界面上方点击 Install 搜索 Code Runner ，下载由 Jun Han 发布的 Code Runner C++环境配置 下载并安装mingw64 http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download 添加 安装路径\\mingw64\\bin 至全局变量 打开按开始菜单，在搜索框输入 environment 找到更改全局变量并点击 在新界面右下角由 全局变量 点击 在新界面下方栏找到 Path 一项双击打开 右上角点击 新建 填入 安装路径\\mingw64\\bin OK 保存并退出 编译器配置 在代码用文件夹创建 .vscode 文件夹并创建 tasks.json ，写入一下内容：（记得替换文件路径） { \u0026#34;tasks\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: g++.exe build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;文件路径（记得改为 \\\\ 形式）\\\\mingw64\\\\bin\\\\g++.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 创建你的 c++ 文件并点击右上角三角号运行吧！ ","date":"2023-02-19T00:00:00Z","permalink":"/posts/c++/cpp-00compilerenvironment/","title":"从0开始的C++语言基础00：编译器及C++环境的设置"}]