<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>01-Basis on zayn_lie&#39;s blog</title>
        <link>/categories/01-basis/</link>
        <description>Recent content in 01-Basis on zayn_lie&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 05 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/01-basis/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>从0开始的算法竞赛01-算法基础03：贪心</title>
        <link>/posts/algorithm/01-basis/2023-03-05-03-greedy/</link>
        <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-05-03-greedy/</guid>
        <description>&lt;h3 id=&#34;why-为什么要学贪心算法&#34;&gt;WHY: 为什么要学贪心算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我相信大家愿意跟着我建立算法和 c++ 体系的原因是体系的逻辑性及减少凭感觉解决问题，这也是本博客的目的。但是，凡事没有绝对。在算法中，有一种凭感觉解决问题的方法也成立了自己的体系 —— 贪心。&lt;/li&gt;
&lt;li&gt;贪心具有一切凭感觉解决问题的优点 —— 快速，正确率与练习的次数（刷题）成正比等等。或者说，贪心就是凭感觉解决问题的一种体现。所以，贪心的证明一般都是 &lt;em&gt;反证法&lt;/em&gt; 和 &lt;em&gt;归纳法&lt;/em&gt; 。换句话说，都是倒着推的。&lt;/li&gt;
&lt;li&gt;既然如此，那为什么我们还要讲贪心呢？&lt;/li&gt;
&lt;li&gt;其一，有些竞赛题目就是对着贪心算法设计出的，虽然运用了贪心一定还有其他解法（这只是个人观点，毕竟我看过的贪心题目大部分都可以用动态规划解决，但是动态规划解决的情况下往往更复杂），但是运用贪心可以最快的解决问题。&lt;/li&gt;
&lt;li&gt;其二，贪心作为整个逻辑体系的唯一较凭感觉的部分，可以让我们在算法学习过程中放松下大脑，在纯粹的理性中获得一些感性。这对于整体循序渐进的算法学习是有好处的（相信我，这么学到最后，你反而会觉得贪心是最有意思的）。&lt;/li&gt;
&lt;li&gt;最后，在无数日夜的反复思考中（&lt;del&gt;别误会，算法不是我女朋友&lt;/del&gt;），我找到了 &lt;em&gt;&lt;strong&gt;正着推&lt;/strong&gt;&lt;/em&gt; （&lt;del&gt;当时很激动！必须加粗 + 斜体！&lt;/del&gt;） 贪心的方法，这种正着推的方法需要的条件就是：题目本身条件+你知道它要你用贪心
&lt;ul&gt;
&lt;li&gt;难的是你怎么知道它要你用贪心？这是得靠刷题和感觉的。但是放心，我已经削减了贪心中大部分需要感觉的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是贪心&#34;&gt;WHAT: 什么是贪心？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;贪心算法，简单来说就是带着很贪心的心态解决问题。不考虑长远目标，就只看到眼前利益。把眼前利益放到最大，这就是贪心。&lt;/li&gt;
&lt;li&gt;但是贪心的最终目的还是解决长远（最终）问题。所以，你还得保证眼前利益放最大时，长远的利益也是最大。这就是贪心算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-怎么使用贪心算法&#34;&gt;HOW: 怎么使用贪心算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;贪心解题分3个步骤：（别忘了，现在学的所有方法都是位于第0节课分析问题中的 &lt;em&gt;方法选择&lt;/em&gt; 步骤）
&lt;ul&gt;
&lt;li&gt;首先，确认题目希望你用贪心（或者你也可以先试试用贪心行不行的通）&lt;/li&gt;
&lt;li&gt;然后，确认贪心的 &lt;em&gt;维度 x&lt;/em&gt; （维度需要是连续的） 和 &lt;em&gt;对象 y&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;最后，对于每个单位的维度对对象进行分析，逻辑推理这么贪心是否行的通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;很抽象，别担心，我们先不讲题目，我们用现实中的贪财来深刻理解下
&lt;ul&gt;
&lt;li&gt;一个人很贪财（他感觉钱包&lt;del&gt;题目&lt;/del&gt;想要让他贪心）&lt;/li&gt;
&lt;li&gt;他于是目光短浅，就只想今天赚最多的钱
&lt;ul&gt;
&lt;li&gt;这里， &lt;em&gt;维度 x&lt;/em&gt; 就是时间（今天）， &lt;em&gt;对象 y&lt;/em&gt; 就是钱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;于是他开始逻辑推理，如果他每天都赚最多的钱放到钱包里，那么长久来讲他的钱应该最多吗？可惜他找到了逻辑漏洞：如果有一天我把钱投资出去，得到的回报会更多。因此贪心是不行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尽管在这个例子中贪心算法失效，但是也很好的展示了如何使用贪心算法解决问题。就像这个例子一样，如果选择贪心必然会可能出现失效，但是及时止损，改变方法就行了 —— 况且贪心的逻辑推理一般也不会浪费很多的时间。所以如果对于是否使用贪心还是没感觉或者不确定，那就试试好了。&lt;/li&gt;
&lt;li&gt;现在我们对贪心有了大概的概念，贪心又是要靠刷题培养感觉的，我们就来看看部分具体的体型和题目吧 —— 背包问题和区间问题（接下来默认第一步已完成：你已经知道题目要你贪心了）。&lt;em&gt;注：这里的题目分类是从《算法竞赛入门经典》（刘汝佳）获得灵感，但是书上对于部分题目的讲解是倒着推的，因此我将在这里展示如何正着推导分析问题&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;背包问题&#34;&gt;背包问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分数问题：有 n 个物品，第 i 个物体的重量为 w_i ，价值为 v_i ，物体可切割，每件物品重量与价值成正比。在总重量不超过 C 的情况让价值尽可能高。
&lt;ul&gt;
&lt;li&gt;维度 x ：重量，对象 y ：价值&lt;/li&gt;
&lt;li&gt;对于每个重量，只要取得是性价比（重量价格率）最高，当前价值最高的即可。这么取到最后的重量必然背包装的东西价值最高，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整数问题
&lt;ul&gt;
&lt;li&gt;有 n 个物品，第 i 个物体的重量为 w_i ，不可切割。在总重量不超过 C 的情况让选的物品尽可能多。
&lt;ul&gt;
&lt;li&gt;维度 x ：物品数，对象 y ：重量&lt;/li&gt;
&lt;li&gt;对于每一个物品，只要当前的重量最小即可节省最多空间（空间利用率最高），那么最后选的物品必然会尽可能多，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有 n 个物品和无数个背包，每个背包能装下一个或两个总重量不超过 C 的东西。求最少要用几个背包装下所有东西。
&lt;ul&gt;
&lt;li&gt;维度 x ：背包数，对象 y ：重量&lt;/li&gt;
&lt;li&gt;对于每个背包，只要当前的重量装的越满（空间利用率最高），节省的空间就越多，在尽量少的空间内可以装的东西就越多。最终所用的空间或背包就越少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大家应该可以总结出了：对于每一个维度 x ，对对象 y 进行贪心。最终的结果最好时，贪心成立。我们的维度 x 可以说重量，物品数，背包数。因此寻找维度 x 和对象 y 尤为关键，接下来我们来看一看更为抽象的区间问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;区间问题&#34;&gt;区间问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;安排问题：有一批活动 a_i 从 o_i 号开展到 f_i 号。部分活动的举办日期有重叠，但且一个活动一旦开展，必须开展完毕才能开展下一个活动。要求在 N 日内开展尽量多的活动。
&lt;ul&gt;
&lt;li&gt;维度 x ：日期，对象 y ：活动数&lt;/li&gt;
&lt;li&gt;对于从第一天到当天，要尽可能开展多的活动，就要赶快开展下一个活动，也就是上一个活动就得早点结束。再推导下，越早结束的活动越优先安排。如果对于每天都能找到当天结束的活动，安排下一次活动最终能够安排的活动最多，贪心成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查问题：有一批已经安排好的活动 a_i 从 o_i 号开展到 f_i 号，部分活动的举办日期有重叠。要求设立最少的检查时间点，能够检查到每一个活动。
&lt;ul&gt;
&lt;li&gt;维度 x ：日期，对象 y ：检查点&lt;/li&gt;
&lt;li&gt;对于从第一天到当天，要检查点越少，就最好硬把检查点拖得越晚越好 —— 因为这样还有可能能检查到下一个活动，一举两得。最晚什么时候呢？当然你再晚不可能也不检查你本来需要检查的那些活动 —— 你需要检查的那些活动中最早结束的那天。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;练习&#34;&gt;练习&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;这里就不再布置练习了，因为作为感性的解决方案需要多而杂的贪心问题的练习。大家可以自行在洛谷上选择 &lt;code&gt;贪心&lt;/code&gt; tag 自行练习。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>从0开始的算法竞赛01-算法基础04：排序</title>
        <link>/posts/algorithm/01-basis/2023-03-05-04-sort/</link>
        <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-05-04-sort/</guid>
        <description>&lt;h3 id=&#34;why-为什么学排序相关的算法&#34;&gt;WHY: 为什么学排序相关的算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实际上，我们学排序并不是因为排序本身，毕竟 c++ 本身已经又自己的排序函数 &lt;code&gt;std::sort(头指针，尾指针，（规则）)&lt;/code&gt; 位于 &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt; 头文件中。而且这个排序一般比我们自己写的时间复杂度更低。&lt;/li&gt;
&lt;li&gt;我们学排序是为了对前面的基础算法有一个回顾，加深算法的印象，更好的掌握好基础算法，才能在接下来的学习中更顺利。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what--how&#34;&gt;WHAT &amp;amp; HOW&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我并不打算讲排序有关内容，因为前人已经整理的很完整了： &lt;a class=&#34;link&#34; href=&#34;https://oi-wiki.org/basic/sort-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OI WIKI: SORT&lt;/a&gt; 如果后面突然又什么好的理解会再更新重写的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>从0开始的算法竞赛01-算法基础00：你真的会分析算法问题吗？</title>
        <link>/posts/algorithm/01-basis/2023-03-02-00-introtoalgorithm/</link>
        <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-02-00-introtoalgorithm/</guid>
        <description>&lt;h3 id=&#34;why-为什么要分析算法问题我怎么知道我是分析还是凭感觉&#34;&gt;WHY: 为什么要分析算法问题？我怎么知道我是分析还是凭感觉？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你真的有这种疑惑，那么你大概率平时是靠感觉解决问题的 —— 我并不是说我们并不能靠感觉解决问题的，且凭感觉解决问题也是很重要的一项技能（凭感觉解决问题其实并不是什么不好的方式，其实就是第六感），凭感觉有着速度快、和经验正相关的精准等优点。但是作为理科竞赛，我更希望凭感觉少些，分析的成分多些。这样在你一些从没有遇到类型的问题你也可以得出正确答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是凭感觉什么是靠分析&#34;&gt;WHAT: 什么是凭感觉？什么是靠分析？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;凭感觉准确是指一眼看题目便能不经过任何考虑便知道怎么解决，一个很简单的例子就是 &lt;em&gt;7 * 7 = ？&lt;/em&gt; ，你能够直接回答出乘法口诀表七七四十九。而不是分析：拆分成7个7进行相加。这就是我对凭感觉的定义。另外一个突出的例子就是网上各大媒体流传的《秒杀高考/中考题目》的各种技巧。很显然，凭感觉的最突出优点就是快。但是当问题复杂时（条件不足、没有见到）很容易就没法得出正确答案。&lt;/li&gt;
&lt;li&gt;分析就是形成一套万能的体系机器，无论是什么问题输入机器后通过机器内的逻辑加工都能的出正确答案。例如我在写每一章知识时都将知识拆分成 &lt;em&gt;WHY WHAT HOW&lt;/em&gt; ，这便是 &lt;em&gt;分析&lt;/em&gt; 中的 &lt;em&gt;拆分&lt;/em&gt; 。当然，因为它的通用性导致它的速度肯定不如凭感觉。但是它是最稳定的正确答案输出器，且符合理科竞赛的靠逻辑本质。所以我将在本章详细将如何分析一个算法题目。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-怎么分析一道理科题目&#34;&gt;HOW: 怎么分析一道理科题目？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先，一道理科题目一般由这几个部分组成： &lt;em&gt;背景 主体 数据 样例&lt;/em&gt; 。 我们来看这个样例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Farmer John(FJ) 的奶牛很喜欢学习，他们看到FJ学了编程也想参与其中，但是在阅读编程书籍的时候出现了问题。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 这本编程书籍一上来就要求编译一个程序计算 a + b 的值。但是他们才第一天学，什么都不知道。请问你可以帮助他们写一个样例吗做个示范吗？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 输入一行a和b，用空格隔开。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 输出一行，输出 a + b 的值。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 样例：输入：1 1 输出：2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 数据范围：0 &amp;lt; a, b &amp;lt; 10^9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;我们来分析下这个样例：
&lt;ul&gt;
&lt;li&gt;背景：第一行就是背景了（该样例虽然是我自己编的，但是以后看到 Farmer John 和奶牛就可以猜是 &lt;code&gt;USACO&lt;/code&gt; 的题目，这毕竟是他们题目背景的特色）。该背景基本上没啥用，就是放松下，顺便彰显下作为理科生毫无编故事能力。基本可以直接跳过。&lt;/li&gt;
&lt;li&gt;主体：主体在第三行，主体也经常会和背景混杂在一起。对于主体，我们要会提取关键信息。关键信息一般是提出的问题，例如这里“帮助写样例”是关键，而什么样例 —— “a + b 程序” 也成了关键。关键信息的提取一般需要经过训练培养感觉，不要浪费太多时间。&lt;/li&gt;
&lt;li&gt;数据：为什么主体问题提取不要浪费太多时间？因为即使关键提取的较为模糊，数据也会帮你把关键信息打磨干净。这里数据位于4、5和最后一行 —— 包含了输入输出和范围。就算你主体的关键信息没提取清楚，看到输出你也清楚了 —— 就是一个输出 a + b 的程序嘛。至于范围，一般都是在题目的最后。你一般需要利用范围选择合适的结构和数据类型来解决问题。&lt;/li&gt;
&lt;li&gt;样例：样例一般是作为测试的数据。它一般较为简单，方便你调试。用于写完写程序时的模拟和程序后的检验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们已经知道了一个题目的结构，接下来就是分析解决问题了：
&lt;ul&gt;
&lt;li&gt;建立模型：就是把实例问题数学化。就类似我们一般会把鸡兔同笼问题转化为二元一次方程一样，这就是模型的建立。&lt;/li&gt;
&lt;li&gt;模拟&amp;amp;拆分：
&lt;ul&gt;
&lt;li&gt;模拟：我们在心里模拟一边代码的大致运行路程，或者说模拟就是题目说什么我们就写什么不做任何优化。例如题目说有一组背包，每个背包重多少时，我们就建立一个数组，把这个数组用来储存背包重量，题目说每个背包减轻了30kg，我们就把数组的每个元素都减30&amp;hellip; 实际上模拟虽然很多教练都特别提出来讲，但是其实没有什么必要 —— 我们每道题实际上都有用到模拟，只是多数情况下在脑中模拟而已。&lt;/li&gt;
&lt;li&gt;拆分：在模拟过后，我们对程序有了个大致的框架想法，这时候就可以把一个大问题拆分成几个小问题了。先把简单的问题解决，难的问题再经过后续步骤得出方案。（更系统的拆分叫做 &lt;em&gt;分治&lt;/em&gt; ，这里就不细说了，有兴趣可以自己了解下。 &lt;em&gt;分治&lt;/em&gt; 还特意加入了合并步骤，更加的科学合理。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法选择：对于每个子问题选择最优的方案。实际上，我们接下来讲的各种递归，二分等都是方法，运用在这一步骤。&lt;/li&gt;
&lt;li&gt;代码转化：将方案转化为代码。&lt;/li&gt;
&lt;li&gt;复杂度优化：最后分析是否有更好的结构、方法可以提高代码速度、减少占用空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当然，这种分析只是一个框架，具体问题仍需具体分析。但是，当我们将每个问题放到这个框架中，便可以越来越熟悉，将框架转化为一种习惯或者说感觉。最终达到准确率和速度都提升的效果。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>从0开始的算法竞赛01-算法基础01：递归和枚举</title>
        <link>/posts/algorithm/01-basis/2023-03-02-01-recursionenumeration/</link>
        <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-02-01-recursionenumeration/</guid>
        <description>&lt;h2 id=&#34;递归recursion&#34;&gt;递归(Recursion)&lt;/h2&gt;
&lt;h3 id=&#34;why-为什么要学递归&#34;&gt;WHY: 为什么要学递归？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先我们先明确，算法其实是另外一种形式的数学 —— 它们解决问题的思路很相近，及通过一系列的计算得出结果。但是在计算机的帮助下，算法能干更多数学干起来很麻烦的事情 —— 一些重复、模板性的问题。&lt;/li&gt;
&lt;li&gt;而递归，作为算法的第一课，便很好的体现出算法和数学的异同之处。递归，可以化简大量的重复性问题。因此学会递归，我们便可以利用计算机化简许多问题的运算过程。&lt;/li&gt;
&lt;li&gt;可能不太好理解，没关系，我们先往下看看递归是什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是递归&#34;&gt;WHAT: 什么是递归？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们先来看下这个函数公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
f(x) =
\begin{cases}
0, &amp;amp; x \leq 7 \
f(x - 1), &amp;amp; x &amp;gt; 7 \
\end{cases}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很显然，当 $x \leq 7$ 的时候 $f(x)$ 均等于0。但是当 $x = 10$ 的时候呢？
&lt;ul&gt;
&lt;li&gt;$f(10) = f(9) = f(8) = f(7) = 0$&lt;/li&gt;
&lt;li&gt;当 $x &amp;gt; 7$ 的时候有没有一种感觉，就是这个 $f(x)$ 的 $x$ 一直在 &lt;em&gt;传递&lt;/em&gt; 到下一个 $f(x)$ ，只是自身每次减一？&lt;/li&gt;
&lt;li&gt;当 $x = 7$ 时， $f(x)$ return 0时候有没有一种感觉这个0在不断 &lt;em&gt;回归&lt;/em&gt; 到 $f(10)$ ?&lt;/li&gt;
&lt;li&gt;这种 &lt;em&gt;传递&lt;/em&gt; 和 &lt;em&gt;回归&lt;/em&gt; 的感觉就叫做 &lt;em&gt;递归&lt;/em&gt; 。或者说， &lt;em&gt;递归&lt;/em&gt; = &lt;em&gt;传递&lt;/em&gt; + &lt;em&gt;回归&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;很多教材喜欢举一些很有趣但是对初学者很不友好的例子： &lt;em&gt;想要知道递归，就得先知道递归&lt;/em&gt; ， &lt;em&gt;自己调用自己&lt;/em&gt; 等等。但是经过我利用上面数学公式的举例，相信你能看得懂这些玩笑了。实际上，这些例子都是在强调 $f(x) = f(x - 1)$ 的过程。但这只是 &lt;em&gt;传递&lt;/em&gt; 的过程。&lt;/li&gt;
&lt;li&gt;另外，通过这里例子，我们还可以加深算法与数学异同的理解。数学遇到这种公式一般需要转化为其他公式（就想上面的展开 $f(10) = f(9) = f(8) = f(7) = 0$ 等等）再求解，这其实如果数据一大，公式一复杂，求解就会变得困难。而算法，正盼望着你把问题转化为这种 &lt;em&gt;自己调用自己&lt;/em&gt; 形式，那剩下的求解呢？交给计算机就可以了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-递归怎么写&#34;&gt;HOW: 递归怎么写？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;递归分为传递和回归，传递就是往下的方式，回归就是限制条件回来的过程。很抽象，我们还是看刚刚那个公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
f(x) =
\begin{cases}
0, &amp;amp; x \leq 7 \
f(x - 1), &amp;amp; x &amp;gt; 7 \
\end{cases}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里传递就是 $f(x) = f(x - 1)$ ，方式就是 $x$ 自己减一。&lt;/li&gt;
&lt;li&gt;回归的限制条件是 $x \leq 7$ 。&lt;/li&gt;
&lt;li&gt;如果这些都能理解，我再告诉你个条件。在程序函数中，是可以自己调用自己的，那即使你只学过我 &lt;em&gt;0基础c++体系-函数&lt;/em&gt; 的第一节课应该可以写的出来这个函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; f(x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这就是递归函数该怎么写。虽然内容较少，但是递归将伴随整个算法生涯，甚至后面递归我们不会再强调，而是把它当作一种和加减乘除一样常见的方法。所以希望本节课大家能好好理解。特别是注意写递归时不仅要有传递，还要有回归（限制条件要写清楚）。如果没有限制条件或者条件不当，程序将无限运行下去，知道内存超标。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;枚举enumeration&#34;&gt;枚举(Enumeration)&lt;/h2&gt;
&lt;h3 id=&#34;why-为什么要学枚举&#34;&gt;WHY: 为什么要学枚举&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;和递归类似，枚举也是让计算机帮助我们列举情况，找到我们要求的解。掌握枚举也可以让我们再调试和运行时提高一定的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是枚举&#34;&gt;WHAT: 什么是枚举&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实际上，在你学 &lt;code&gt;for(;;)&lt;/code&gt; 和 &lt;code&gt;while()&lt;/code&gt; 的时候，你已经开始接触枚举了。我们当时只不过是通过循环把每一种情况列举出来，这就叫枚举。但是枚举的方式不仅仅只有循环，想本章的递归也可以作为枚举的一种方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-怎么写枚举&#34;&gt;HOW: 怎么写枚举&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;循环：关于循环的枚举已经在 c++ 基础讲完了。所以这里就强调下注意循环的对象，开始，终点和步长。
&lt;ul&gt;
&lt;li&gt;实际上，循环的枚举往往是可优化的。例如在一个从小到大排列的数组中询问某个数是否存在的时候，往往可以从中间开始列举。如果比中间的数大，则应该在右侧寻找，及对右侧再进行相同操作；如果比中间的数小，则对左侧进行相同操作。直到找到这个数或者是发现这个数在最终两个数之间 —— 不存在。&lt;/li&gt;
&lt;li&gt;这种不断一分为二缩小范围寻找答案的方法叫做二分，是一种常用的枚举优化方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;递归：刚刚的样例已经包含了递归 —— 如果比中间的数大，对右侧进行相同操作 —— 这个相同操作就是递归中的传递。有时候，循环和递归是可以互换的。例如你可以用循环实现刚刚的操作：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; vector, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(vector) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(vector[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// r 为数组的右指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(vector[l] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; vector[r]){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(vector[m] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; vector[r] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; vector[l] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target) &lt;span style=&#34;color:#75715e&#34;&gt;// 预先看下左边界有边界是否相等，避免遗漏
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(vector[m] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(vector[m] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当循环和递归可以同时实现的时候，更推荐用循环的形式。因为递归在传递还未回归的时候那些传递过程中的函数在计算机运算时需要存起来（想想为什么），可能导致内存占用变高。&lt;/li&gt;
&lt;li&gt;最后希望各位能够认真完成这节课 US 和 MS 的 GCD 和 LCM ，其困难在许多体制内学生并不认识辗转相除法。大家自行了解后尝试解决，对于本节课可以有更深的了解。&lt;/li&gt;
&lt;li&gt;这节课内容虽少，但是对于之后的学习非常重要。因此我会在 ANS 对于每道题目做出较详细的讲解。希望大家无论是否做出来了也认真的看完题解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;练习&#34;&gt;练习&lt;/h2&gt;
&lt;h3 id=&#34;kn&#34;&gt;KN&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;请写出一个函数 A(x, y) ，要求返回 x 中取 y 个元素进行排列的所有种类数。&lt;/li&gt;
&lt;li&gt;请写出一个函数 C(x, y) ，要求返回 x 中取 y 个元素进行组合的所有种类数。&lt;/li&gt;
&lt;li&gt;想想能不能进行优化？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;我们先来讲讲排列组合怎么算
&lt;ul&gt;
&lt;li&gt;从 x 中选取 y 个进行排列，那么我们就对 y 中的每个元素进行枚举：第一个元素一共有 x 种选法，第二个元素一共有 x - 1 种选法，第三个元素一共有 x - 2 种选法&amp;hellip; 第 y 个元素一共有 x - y + 1 种选法。因此一共有 $x(x - 1)(x - 2) \dotsm (x - y + 1)$ 种选法。通过阶乘我们还可以表示成更简单的方法 $\frac{x!}{(x-y)!}$。这就是排列。&lt;/li&gt;
&lt;li&gt;而对于组合，实际上就是把排列中的部分情况去除掉： ABC, ACB, BAC &amp;hellip; 在组合中是相同的，因此只保留一个。那么一共有多少种相同的情况呢？如果再观察可以发现，每一种情况相当于是自己本身的排列。 ABC, ACB, BAC &amp;hellip; 实际上就是 ABC 的 A(3, 3) 的排列。所以再原来基础上只要再除掉一个 A(y, y) 就是正确答案了。那么可以表达为 $\frac{x!}{y!(x - y)!}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那么第一反应的程序是这个样子的：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// ans = answer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; y; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; y; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; y; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;可以化简，因为我们知道组合是排列的除掉部分情况的结果，直接调用 A 函数即可：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A(x, y);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; y; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;分析可以知道， A 乘和除掉了一部分相同内容，我们不要枚举除掉的部分其实就可以达到效果了。因此对 A 再化简：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这验证了我们上面所述，枚举一般都可以进行优化。当然这里只是对枚举的过程优化，实际上我们学到后面还会学到直接对整个枚举这个方法进行优化等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;us&#34;&gt;US&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;请写出一个函数 &lt;code&gt;GCD(x, y)&lt;/code&gt; ，要求返回 x 和 y 的最大公因数。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P1888&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;luogu-P1888 三角函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;接下来我们来说一说 GCD （最大公因数）怎么算
&lt;ul&gt;
&lt;li&gt;首先我要拿辗转相除法说下“正着推”和“反着推”的区别和好坏
&lt;ul&gt;
&lt;li&gt;很多人了解辗转相除法的公式，但是问为什么的时候，教练一般从辗转相除法的公式入手，有的运用假设法（假设辗转相除法不成立），有的运用从公式开始推导到条件法等等。这些实际上都是反着推。他们先知道了结论才给你推的出来。这其实不叫“为什么”，这个叫“怎么证明”。换句话说，“反着推”就是如果你不知道这个公式你就推不出来，你必须先知道，先背住这个公式才推的出来。这个好处就是很快，你都背住了竞赛直接用即可。但是很容易忘，而且遇到没见过的也推不出来。&lt;/li&gt;
&lt;li&gt;是不是觉得在哪里见过？没错，在我讲第0节课“凭感觉”和“靠分析”的时候出现过“速度”和“准确”的区别。其实“逆着推”也可以算作一种凭感觉的解决方法问题。我也讲过理科竞赛讲究的不是感觉而是分析。那么“正着推”作为靠分析的手段，我们怎么“正着推”辗转相除法？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;首先我们要求 x 和 y 的最大公因数 z ，那么我们知道的条件是 $x = z \cdot a, y = z \cdot b (z, a, b, x, y \in Z)$ 那么我们有两条路，一条是继续推导公式，一条是拆分或化简问题。因为现在是独立的两个条件，而我们需要的是一个通解，这时候我选择继续推导公式，将这5个变量联系在一起。因此有 $x - y = z \cdot (a - b)$ 通过推导和观察我们发现，z也是(x - y)的因数（我们假设 $x &amp;gt; y$）。但是(x - y)必定比x, y都小，因此，z又是y和(x - y)的GCD。有什么意义呢？大家发现，这一步我其实化简了问题：把两个很大的数开始变小，并且这两个较小数和原来的两个较大的数有联系并经过了 &lt;em&gt;相同操作&lt;/em&gt; 。&lt;em&gt;相同操作&lt;/em&gt; ，对，有没有发现什么 —— 递归！计算机给了我么另外一个思路，把公式转化相同形式的运算也可以！那么我们得出了一个结论：$GCD(x, y) = GCD(y, x - y)$。脑中模拟一边过程，发现那么只要这么一直重复下去x, y一定会越来越逼近0（因为x, y一定一直减小），在等于0的前一刻呢？x必然等于y, 因为x - y才等于0。那这时候x = y这个值不就是原来的GCD(x, y)吗？&lt;/li&gt;
&lt;li&gt;接下来我们看看能不能优化。因为过程中出现了很多次x - y，当x很大时必然会减很多次y，这产生了很多操作。那能不能化简呢？就是让x减去最多的y但是仍然大于0？很多人想到了 —— 模运算！ $x \mod y$ 就是操作了最多次x - y的结果！那么我们就优化出了这个公式 $GCD(x, y) = GCD(y, x \mod y)$ 这就是辗转相除法（因为模运算涉及除法的余数）&lt;/li&gt;
&lt;li&gt;这就是正着推的辗转相除法，从条件推导公式而不是从公式推导条件！相信这么推一次大家印象一定很深刻。即使以后忘记只要记着遇见条件想办法进行 &lt;em&gt;推导&lt;/em&gt; ， &lt;em&gt;拆分&lt;/em&gt; 和 &lt;em&gt;化简&lt;/em&gt; 就能得出正确答案！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此递归公式得到后，程序就好实现了：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GCD&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x){ &lt;span style=&#34;color:#75715e&#34;&gt;//让x &amp;gt;= y，统一化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 递归的回归条件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; GCD(y, x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; y);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;相信写完这个程序大家能够对递归有着更深刻的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mt&#34;&gt;MT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;请写出一个函数 LCM(x, y) ，要求返回 x 和 y 的最小公倍数。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P1029&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;luogu-P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;推完了 GCD ，大家可以自己想想很相似的 LCM 。这里只要注意因为类似排列和组合相似性， LCE 和 GCD 的公式会存在关联。大家可以自己尝试下正推。我这里给出函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LCM&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; GCD(x, y);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>从0开始的算法竞赛01-算法基础02：时间和空间</title>
        <link>/posts/algorithm/01-basis/2023-03-03-02-timespace/</link>
        <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>/posts/algorithm/01-basis/2023-03-03-02-timespace/</guid>
        <description>&lt;h3 id=&#34;why-为什么要关注时间和空间&#34;&gt;WHY: 为什么要关注时间和空间&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;想象你面前有两个程序可以实现你的目的。 A 程序需要 1 GB 的内存来运行且要跑1个小时才能得出答案， B 程序需要 1 KB 内存需要跑1秒钟得出答案，你会选择哪个程序。很显然， B 程序。&lt;/li&gt;
&lt;li&gt;不仅如此，算法竞赛中大多都会限制你所使用的空间（内存）和时间。并且往往时间的限制更严格（毕竟现在 CPU 等硬件可以不断的扩大内存，但是时间仍然对人类很宝贵）。&lt;/li&gt;
&lt;li&gt;那我们怎么测量时间和空间呢？ —— 时间复杂度和空间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-什么是时间复杂度和空间复杂度&#34;&gt;WHAT: 什么是时间复杂度和空间复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们先来看一个函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execute &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execute &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n; j &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execute &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; a &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; b &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; c &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execute &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;运行一次这个程序要多久？很显然，要进行 $1 + n + n^2 + n^3$ 次操作。相比一个要进行 &lt;code&gt;run2(n)&lt;/code&gt; $n + n^2 + n^3$ 的程序一定更慢，相比 &lt;code&gt;run3(n)&lt;/code&gt; $1 + n + n^2$ 当n不为0时也更慢。&lt;/li&gt;
&lt;li&gt;我们来考虑两种情况，当n很小（趋近0）时，显然 $run2 &amp;lt; run3 &amp;lt; run1$。当n很大时（趋近正无穷）时， $run3 &amp;lt; run2 &amp;lt; run1$ 。那如果你要选一个程序来跑，你会选择 run2 还是 run3 ？&lt;/li&gt;
&lt;li&gt;也许你会反应过来，当n很小时，虽然run2更快，但是大家本身都很快，run3也许运行个1ms，run2只运行0.99999ms，但我哪感受的出来？而且如果有个时间限制，run2和run3一定都不会超出限制。但是n很大的时候，run2因为三次方的数量级增长的很快，一下就会慢run3很多。所以我们都会选择run3来运行。&lt;/li&gt;
&lt;li&gt;通过这个例子，大家会有一个模糊的概念，我们关注时间的时候往往关注的是最高次方（或者增长最快的哪一项），因为我们在评价程序快慢的时候只有在 n 很大的情况下评价才有意义， n 很小大家速度都差不多，是没什么意义的。所以我们就创造了一个符号来表示程序运行的最高次项（或增长最快的项） - $O$ ，称为时间复杂度。例如run1和run2的时间复杂度为 $O(n^3)$ ，run3的时间复杂度为 $O(n^2)$ 这下谁快谁慢就显而易见了。&lt;/li&gt;
&lt;li&gt;知道了时间复杂度，那空间复杂度是什么？还记得例如递归的函数里面套函数吗？当函数运行一半跑去运行另一个函数时，这个函数还没返回值就会先占用一定的内存。另外你用的参数越多，占用的内存也越多。比如你开一个 10^9 的数组一定比开 10 的数组占用的空间多。因此我们知道空间复杂度和调用的函数深度（函数里面调用函数的次数，每次就像往深处又探了一点）与参数的使用相关。那计算公式呢？其实不太重要。因为你只要注意这两点基本上就不再会遇到空间不足的问题了 —— 毕竟正如上面所说，竞赛重时间轻空间。并且这里还可以回顾上章所说为什么如果递归的回归没有加限制条件往往会爆内存 —— 函数无线的深探下去，占用的内存越来越多，最终导致 CPU 内存占满程序运行错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-怎么测量时间复杂度怎么优化时间复杂度&#34;&gt;HOW: 怎么测量时间复杂度？怎么优化时间复杂度？&lt;/h3&gt;
&lt;h4 id=&#34;测量时间复杂度的测量&#34;&gt;测量时间复杂度的测量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据上面的例子，我们可以知道时间复杂度只与最高次项有关，那次项间怎么对比呢？我们来看这组关系：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
1 &amp;lt; \log{n} &amp;lt; n &amp;lt; n \cdot \log{n} &amp;lt; n^2 &amp;lt; n^2 \cdot \log{n} &amp;lt; \dotso
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这么多实际上只要知道 $1 &amp;lt; \log{n} &amp;lt; n$ 即可，剩下的自己组合相乘。&lt;/li&gt;
&lt;li&gt;1 用在正常的语句，没有枚举循环递归等等，最正常最快的时间复杂度。有些人会有为什么不是2，3之类的疑惑（当有2个或3个语句）。实际上，这些系数都是搭配常数，不影响整体的上升趋势，比起趋向无限大的n时均可忽略不计，常数无论搭配哪种系数绝对比不过一次二次的n。同理，如果操作次数为 $2 \cdot n$ 我们也仍写作 $O(n)$ 。&lt;/li&gt;
&lt;li&gt;n 就是正常只有一个循环就是 $O(n)$ ，循环里套一个循环娃就是 $O(n^2)$ ，循环里套的娃再套一个娃就是 $O(n^3)$&lt;/li&gt;
&lt;li&gt;$O(\log{n})$ 的时间复杂度实际上在上一节课枚举中找已经排好的元素中是否存在某个元素就出现过。大家发现我们每次提出中间然后一分为二，不断的一分为二（专业称为二分）就创造出了 $\log_{2}{n}$ 次操作。但是底数2仍然只是个常数，因为 $\log_{2}{n} = \frac{\log_{a}{n}}{\log_{a}{2}}$ 其中 $\log_{a}{2}$ 作为常数不影响整体趋势，因此我们直接写成 $\log{n}$ 即可。
&lt;ul&gt;
&lt;li&gt;有二分就有倍增，倍增也是可以将 $O(n)$ 优化为 $O(\log{n})$ 的一种常用手段。倍增的理解这里就不再提及了，有一篇很好的理解方式推荐给大家：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/jarjingx/article/details/8180560&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;倍增与兔子的故事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那 $n \cdot \log{n}$ 应该也不难理解：循环里套一个二分就是 $O(n \cdot \log{n})$&lt;/li&gt;
&lt;li&gt;剩下的都是一样的道理，至于一些我们没见过的时间复杂度会在后面遇到的时候再讲。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时间复杂度的优化和前缀和&#34;&gt;时间复杂度的优化和前缀和&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;大家发现我们没有提到空间复杂度，还是那句话，现代 &lt;em&gt;重时间轻空间&lt;/em&gt; 。因此，我们往往会牺牲空间复杂度来减小时间复杂度，或者说 &lt;em&gt;拿空间换时间&lt;/em&gt; 。这节课我们会介绍拿空间换时间的典型例子 —— 前缀和。&lt;/li&gt;
&lt;li&gt;我们先看下这道题目：已知数组储存有 n 个数，求 t 次第 a 个数到第 b 个数所有数的和（对于每次 a, b 不相同）。&lt;/li&gt;
&lt;li&gt;正常的思路就是从 a 一个一个加到 b ，因此会写出这样的程序：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; vector, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; b; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; vector[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;先问问大家这个程序运行一次的时间复杂度是多少？很容易回答： $O(b - a)$ 。但是是错误的，正确答案是 $O(n)$ 。注意，我讲时间复杂度的时候一直在强调上升趋势，大家发现我 b - a 的限制只会与 n 相关，当 n 越大， b - a 的范围可以越大，换句话说，上升的比例和 n 成正比。所以，正确答案是 $O(n)$。如果调用这个函数的次数为t，那么总时间复杂度为 $O(t \cdot n)$ 。也许你还不是很理解，但没关系，我们接下来会遇到大量对于时间复杂度的考虑和计算，你也会对时间复杂度有更深刻的了解。&lt;/li&gt;
&lt;li&gt;一般来说，枚举都可以进行优化，那这个可不可以进行一些优化（我们接下来课程说的优化一般都将重心放在时间复杂度的优化）呢？照样，我们不会像某些竞赛教练先告诉大家有前缀和然后逆推到结论：前缀和能优化时间复杂度，我们照样按照逻辑正着推。大家发现，我能优化的点只有在这个循环上 —— 毕竟你不能改变函数的调用次数。那怎么优化呢？还记得我们可以 &lt;em&gt;拿空间换时间&lt;/em&gt; ，那么我希望能够先储存一定的信息，然后通过这个信息能够直接快速的得出 a 到 b 的和。那我要储存什么信息呢？什么信息能够在不破坏（不加深）时间复杂度的情况下提前储存和的信息？首先我们可以分析（化简和拆分）这个问题 —— 怎么处理从 a 开始的和 + 怎么处理到 b 结尾的和。然后推导公式 —— 两边如果都添上一个从0开始的和，那就有
a 到 b 的和 = 0到b的和 - 0到a - 1的和。那我们的数组需要储存的信息就是从0到x的和即可（$O(n)$）（我只要储存一次即可），剩下需要访问的话就直接把 &lt;code&gt;vector[b]&lt;/code&gt; 和 &lt;code&gt;vector[a - 1]&lt;/code&gt; 相减即可（$O(t \cdot 1)$）总时间复杂度 $O(n + t) &amp;lt; O(t \cdot n)$ 。因此，我们用一个数组（空间），储存了一些关键信息，成功的化简了时间复杂度。因此程序变成这样：&lt;/li&gt;
&lt;li&gt;前缀和数组构建：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; vector[n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], sum[n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;construct&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; vector[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;主要函数就变成这个样子：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sumFromAToB&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum[b] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum[a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;用数组储存信息化简时间复杂度是一种非常重要的化简方法，在后面线段树、并查集等等都会用到。希望大家能够好好掌握前缀和，掌握这种用空间换时间很基本的方法。我们在今天的练习中还会对前缀和进行拓展，希望大家完成后认真的学习一下题解，相信对大家以后的优化程序能力会有很大提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;练习&#34;&gt;练习&lt;/h3&gt;
&lt;h4 id=&#34;kn&#34;&gt;KN&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P1115&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;luogu-P1115 最大子段和&lt;/a&gt;（运用前缀和）
&lt;ul&gt;
&lt;li&gt;40分基本要求&lt;/li&gt;
&lt;li&gt;100分需要优化遍历：想想哪些步骤是没有必要的？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;40分主要代码：（a是前缀和数组）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1e5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; j &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){ &lt;span style=&#34;color:#75715e&#34;&gt;// [i, j]这个区间之和
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a[j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; ans : a[j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// 比较大小，相当于 ans = max{ans, a[j] - a[i - 1]}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;100分代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1e5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; j &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ans &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a[j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; ans : a[j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[j] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 优化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这里解释下为什么有这个优化。首先我们脑中模拟一遍这个程序，寻找是否存在不必要的操作，可以发现当 &lt;code&gt;a[i]&lt;/code&gt; 小于等于 0 时，无论 i + 1 到 j 的和多大， i 到 j 的和必然小于 i + 1 到 j 的和，因为 i 到 j 的和相当于 i + 1 到 j 的和加上了个小于等于0的数仍然小于等于 i + 1 到 j ，因此其中必然不会有更大的值，就直接跳过了。&lt;/li&gt;
&lt;li&gt;学完动态规划，你会发现即使时间复杂度已经化简到很小了，连空间复杂度还可以再次化简。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;us&#34;&gt;US&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;已知二维数组(n, m)储存有 $n \cdot m$ 个数，求t次第$(x_a, y_a)$ 个数到第 $(x_b, y_b)$ 个数所有数的和（对于每次 a, b 不相同）。
&lt;ul&gt;
&lt;li&gt;提示：如果没思路可以先自行了解下 &lt;em&gt;容斥原理&lt;/em&gt; 再尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;sum 数组构建：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; vector[n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;][m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], sum[n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;][m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;construct&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; i &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n; j &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      sum[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vector[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (sum[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sum[i][j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]); &lt;span style=&#34;color:#75715e&#34;&gt;// 括号里的内容及运用容斥原理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;主要函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sumFromAToB&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x_a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y_a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x_b, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y_b){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum[x_b][y_b] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum[x_b][y_a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum[x_a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][y_b] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sum[x_a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][y_a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// 仍然是容斥原理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;mt&#34;&gt;MT&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P2367&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;luogu-P2367 语文成绩&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;提示：既然有前缀和，那为什么不能有前缀差（专业名称：差分）呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;因为差分的思路和前缀和及其相似，这就不过多解释了，详情请见 &lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/solution/P2367&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;题解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;usmt&#34;&gt;US+MT&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P3664&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;luogu-P3664 Modern Art&lt;/a&gt; / &lt;a class=&#34;link&#34; href=&#34;http://www.usaco.org/index.php?page=viewproblem2&amp;amp;cpid=744&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;usaco-17UopP1 Modern Art&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
